<!DOCTYPE html>













<html class="theme-next mist" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
<script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("https://alvabill.ml"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />










  <meta name="baidu-site-verification" content="byPs2b2x73houtcT" />










  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.4.1">


  <link rel="mask-icon" href="/images/favicon.ico?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.1',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: true,
    lazyload: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'JWLLOUHRNH',
      apiKey: '5611be55bcec117cc31f4714874ebbca',
      indexName: 'alvabillBlog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "5ea4435c"
    });
  daovoice('update');
  </script>

  <meta name="description" content="近日在segmentfault社区看到了这么一篇文章，基于前端面试中很常问的一个题目--从输入URL到页面加载发生了什么，作者由此引出了在前端方向上的理应搭建起来的知识体系，深受触动，特此于文章基础上整理一番以梳理一下自身的前端知识体系。">
<meta name="keywords" content="JavaScript,HTTP,浏览器,CSS">
<meta property="og:type" content="article">
<meta property="og:title" content="基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建">
<meta property="og:url" content="http://alvabill.ml/基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/index.html">
<meta property="og:site_name" content="Alvabill">
<meta property="og:description" content="近日在segmentfault社区看到了这么一篇文章，基于前端面试中很常问的一个题目--从输入URL到页面加载发生了什么，作者由此引出了在前端方向上的理应搭建起来的知识体系，深受触动，特此于文章基础上整理一番以梳理一下自身的前端知识体系。">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1522337517997.jpg">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/107/814/107814026-5aa5cafca80bf_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/137/309/1373095523-5a658fc12f1fd_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/236/309/2363096142-5aa5cafc74a50_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/226/254/2262547194-5aa5cafc2e219_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/324/599/3245996893-5aa5cafbecf07_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/316/642/316642185-5aa5cafc36e11_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/588/361/588361506-5aa5cafbe158d_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/138/671/1386713703-5aa5cafbad312_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/169/903/1699039536-5aa5cafb9b136_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/215/179/2151798436-59da4801c6772">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/620/422/620422871-570d14feaf681_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/181/531/1815319493-570948eed9b27_articlex">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/171/264/1712643983-570d14ffae847_articlex">
<meta property="og:updated_time" content="2018-09-07T05:51:53.088Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建">
<meta name="twitter:description" content="近日在segmentfault社区看到了这么一篇文章，基于前端面试中很常问的一个题目--从输入URL到页面加载发生了什么，作者由此引出了在前端方向上的理应搭建起来的知识体系，深受触动，特此于文章基础上整理一番以梳理一下自身的前端知识体系。">
<meta name="twitter:image" content="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1522337517997.jpg">



  <link rel="alternate" href="/atom.xml" title="Alvabill" type="application/atom+xml" />




  <link rel="canonical" href="http://alvabill.ml/基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建 | Alvabill</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alvabill</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives<span class="badge">10</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags<span class="badge">11</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories<span class="badge">4</span></a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />Search</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/alvabill" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="90" height="90" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://alvabill.ml/基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alvabill">
      <meta itemprop="description" content="Alvabill个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alvabill">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-29 17:09:14" itemprop="dateCreated datePublished" datetime="2018-03-29T17:09:14+08:00">2018-03-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-09-07 13:51:53" itemprop="dateModified" datetime="2018-09-07T13:51:53+08:00">2018-09-07</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/" class="leancloud_visitors" data-flag-title="基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Views: </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
             <span class="post-meta-divider">|</span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Symbols count in article: </span>
                
                <span title="Symbols count in article">26k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">43 mins.</span>
              
            </div>
          

          
              <div class="post-description">近日在segmentfault社区看到了这么一篇文章，基于前端面试中很常问的一个题目--从输入URL到页面加载发生了什么，作者由此引出了在前端方向上的理应搭建起来的知识体系，深受触动，特此于文章基础上整理一番以梳理一下自身的前端知识体系。</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章灵感以及原型为“<a href="https://segmentfault.com/a/1190000013662126#articleHeader0" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a>”，本文主要基于该文章基础上进行修改补充以完善自身的知识体系，自用参考为主，侵删（^ - ^）</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>此部分的内容是站在个人视角分析的，并不是说就一定是正确答案</strong></p>
<p>首先明确，计算机方面的知识是可以无穷无尽的挖的，而本文的重点是梳理前端向的重点知识</p>
<p>对于前端向（这里可能没有提到node.js之类的，更多的是指客户端前端），这里将知识点按重要程度划分成以下几大类：</p>
<blockquote>
<p>核心知识，必须掌握的，也是最基础的，譬如浏览器模型，渲染原理，JS解析过程，JS运行机制等，作为骨架来承载知识体系<br>重点知识，往往每一块都是一个知识点，而且这些知识点都很重要，譬如http相关，web安全相关，跨域处理等<br>拓展知识，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特网协议栈，hybrid模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如hybrid开发时，懂原生开发是很重要的）</p>
</blockquote>
<h2 id="梳理主干流程"><a href="#梳理主干流程" class="headerlink" title="梳理主干流程"></a>梳理主干流程</h2><p>知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下主干流程：</p>
<ol>
<li>从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li>
<li>开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</li>
<li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li>
<li>后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</li>
<li>单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</li>
<li>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</li>
<li>CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</li>
<li>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</li>
<li>其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</li>
</ol>
<h2 id="细节内容填充"><a href="#细节内容填充" class="headerlink" title="细节内容填充"></a>细节内容填充</h2><h3 id="从浏览器接收url到开启网络请求线程"><a href="#从浏览器接收url到开启网络请求线程" class="headerlink" title="从浏览器接收url到开启网络请求线程"></a>从浏览器接收url到开启网络请求线程</h3><p>这一部分展开的内容是：浏览器进程/线程模型，JS的运行机制。</p>
<h4 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h4><p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）<br>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p>
<ul>
<li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU进程：最多一个，用于3D绘制</li>
<li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li>
</ul>
<p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1522337517997.jpg" alt="Chrome浏览器的多进程"></p>
<h4 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h4><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：</p>
<ul>
<li>GUI线程</li>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时器线程</li>
<li>网络请求线程</li>
</ul>
<p><em>相关文章：<a href="http://imweb.io/topic/58e3bfa845e5c13468f567d5" target="_blank" rel="noopener">浏览器进程与线程相关</a>、<a href="https://segmentfault.com/a/1190000012925872#articleHeader0" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></em></p>
<h4 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h4><p>输入URL后，会进行解析（URL的本质就是统一资源定位符）<br>URL一般包括几大部分：</p>
<ul>
<li><code>protocol</code>，协议头，譬如有http，ftp等</li>
<li><code>host</code>，主机域名或IP地址</li>
<li><code>port</code>，端口号</li>
<li><code>path</code>，目录路径</li>
<li><code>query</code>，即查询参数</li>
<li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</li>
</ul>
<h4 id="开辟网络请求线程"><a href="#开辟网络请求线程" class="headerlink" title="开辟网络请求线程"></a>开辟网络请求线程</h4><p>每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p>
<p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）</p>
<h3 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" class="headerlink" title="开启网络线程到发出一个完整的http请求"></a>开启网络线程到发出一个完整的http请求</h3><p>这一部分主要内容包括：<code>dns</code>查询，<code>tcp/ip</code>请求构建，<code>五层因特网协议栈</code>等等<br>仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）</p>
<h4 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h4><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p>
<p>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host<br>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP<br>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</p>
<p>而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化</p>
<p>这一块可以深入展开，具体请去网上搜索，这里就不占篇幅了（网上可以看到很详细的解答）</p>
<p><em>相关文章：<a href="http://imweb.io/topic/55e3ba46771670e207a16bc8" target="_blank" rel="noopener">DNS解析 – IMWeb</a>、<a href="http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/" target="_blank" rel="noopener">前端性能优化 - 资源预加载</a></em></p>
<h4 id="tcp-ip请求"><a href="#tcp-ip请求" class="headerlink" title="tcp/ip请求"></a>tcp/ip请求</h4><p>http的本质就是<code>tcp/ip</code>请求</p>
<p>需要了解3次握手规则建立连接以及断开连接时的四次挥手</p>
<p>tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输</p>
<p><strong>三次握手的步骤：（抽象派）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello，你是server么？</span><br><span class="line">服务端：hello，我是server，你是client么</span><br><span class="line">客户端：yes，我是client</span><br></pre></td></tr></table></figure>
<p>建立连接成功后，接下来就正式传输数据</p>
<p>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）</p>
<p><strong>四次挥手的步骤：（抽象派）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">被动方：收到通道关闭的信息</span><br><span class="line">被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure>
<p><em>相关文章：<a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">通俗大白话来理解TCP协议的三次握手和四次分手</a></em> </p>
<p><strong>tcp/ip的并发限制</strong></p>
<p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）</p>
<p>而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求</p>
<p>所以针对这个瓶颈，又出现了很多的资源优化方案</p>
<p><strong>get和post的区别</strong></p>
<p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。</p>
<p>get会产生一个tcp数据包，post两个</p>
<p>具体就是：</p>
<ul>
<li>get请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li>
<li>post请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>，</li>
</ul>
<p>浏览器再发送<code>data</code>，服务器响应200（返回数据）。</p>
<p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）</p>
<h4 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h4><p> <strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong></p>
<p>简括就是：</p>
<p><strong>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong></p>
<p>当然，服务端的接收就是反过来的步骤</p>
<p>五层因特网协议栈其实就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.应用层(dns,http) DNS解析成IP并发送http请求</span><br><span class="line"></span><br><span class="line">2.传输层(tcp,udp) 建立tcp连接（三次握手）</span><br><span class="line"></span><br><span class="line">3.网络层(IP,ARP) IP寻址</span><br><span class="line"></span><br><span class="line">4.数据链路层(PPP) 封装成帧</span><br><span class="line"></span><br><span class="line">5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure>
<p>当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。</p>
<p>OSI七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</span><br><span class="line"></span><br><span class="line">会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</span><br></pre></td></tr></table></figure>
<p><em>相关文章：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门 – 阮一峰</a>、<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI模型 – 维基百科</a></em></p>
<h3 id="从服务器接收到请求到对应后台接收到请求"><a href="#从服务器接收到请求到对应后台接收到请求" class="headerlink" title="从服务器接收到请求到对应后台接收到请求"></a>从服务器接收到请求到对应后台接收到请求</h3><p>服务端在接收到请求时，内部会进行很多的处理</p>
<p>这里由于不是专业的后端分析，所以只是简单的介绍下，不深入</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡</p>
<p>当然了，负载均衡不止这一种实现方式，这里不深入…</p>
<p>简单的说：</p>
<p><strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</strong></p>
<p><em>相关文章：<a href="https://my.oschina.net/liuyuantao/blog/812089" target="_blank" rel="noopener">六大Web负载均衡原理与实现</a></em></p>
<h4 id="后台的处理"><a href="#后台的处理" class="headerlink" title="后台的处理"></a>后台的处理</h4><p>一般后台都是部署到容器中的，所以一般为：</p>
<ul>
<li>先是容器接受到请求（如tomcat容器）</li>
<li>然后对应容器中的后台程序接收到请求（如java程序）</li>
<li>然后就是后台会有自己的统一处理，处理完后响应响应结果</li>
</ul>
<p>概括下：</p>
<ul>
<li>一般有的后端是有统一的验证的，如安全拦截，跨域验证</li>
<li>如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）</li>
<li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li>
<li>等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）</li>
<li>然后就是将这个包从后端发送到前端，完成交互</li>
</ul>
<h3 id="后台和前台的http交互"><a href="#后台和前台的http交互" class="headerlink" title="后台和前台的http交互"></a>后台和前台的http交互</h3><p>前后端交互时，http报文作为信息的载体</p>
<p>所以http是一块很重要的内容，这一部分重点介绍它</p>
<p><strong>建议阅读《htttp权威指南》</strong></p>
<h4 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h4><p>报文一般包括了：<code>通用头部</code>，<code>请求/响应头部</code>，<code>请求/响应体</code></p>
<p><strong>通用头部</strong></p>
<p>这也是开发人员见过的最多的信息，包括如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request Url: 请求的web服务器地址</span><br><span class="line"></span><br><span class="line">Request Method: 请求方式</span><br><span class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</span><br><span class="line"></span><br><span class="line">Status Code: 请求的返回状态码，如200代表成功</span><br><span class="line"></span><br><span class="line">Remote Address: 请求的远程服务器地址（会转为IP）</span><br></pre></td></tr></table></figure>
<p>譬如，在跨域拒绝时，可能是method为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）</p>
<p>其中，Method的话一般分为两批次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</span><br><span class="line">以及几种Additional Request Methods：PUT、DELETE、LINK、UNLINK</span><br><span class="line"></span><br><span class="line">HTTP1.1定义了八种请求方法：GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</span><br></pre></td></tr></table></figure>
<p><code>HTTP 1.0</code>定义参考：<a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1945</a></p>
<p><code>HTTP 1.1</code>定义参考：<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616</a></p>
<p>这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</span><br><span class="line">400——客户端请求有错（譬如可以是安全模块拦截）</span><br><span class="line">401——请求未经授权</span><br><span class="line">403——禁止访问（譬如可以是未登录时禁止）</span><br><span class="line">404——资源未找到</span><br><span class="line">500——服务器内部错误</span><br><span class="line">503——服务不可用</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>再列举下大致不同范围状态的意义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx——指示信息，表示请求已接收，继续处理</span><br><span class="line">2xx——成功，表示请求已被成功接收、理解、接受</span><br><span class="line">3xx——重定向，要完成请求必须进行更进一步的操作</span><br><span class="line">4xx——客户端错误，请求有语法错误或请求无法实现</span><br><span class="line">5xx——服务器端错误，服务器未能实现合法的请求</span><br></pre></td></tr></table></figure>
<p><em>相关文章：<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门 – 阮一峰</a>、<a href="http://www.howardliu.cn/the-introduction-of-http-status-codes/" target="_blank" rel="noopener">HTTP状态码总结</a></em></p>
<p><strong>请求/响应头部</strong></p>
<p>请求和响应头部也是分析时常用到的</p>
<p>常用的请求头部（部分）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Accept: 接收类型，表示浏览器支持的MIME类型</span><br><span class="line">（对标服务端返回的Content-Type）</span><br><span class="line">Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收</span><br><span class="line">Content-Type：客户端发送出去实体内容的类型</span><br><span class="line">Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache</span><br><span class="line">If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中</span><br><span class="line">Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</span><br><span class="line">Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</span><br><span class="line">If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</span><br><span class="line">Cookie: 有cookie并且同域访问时会自动带上</span><br><span class="line">Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive</span><br><span class="line">Host：请求的服务器URL</span><br><span class="line">Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</span><br><span class="line">Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</span><br><span class="line">User-Agent：用户客户端的一些必要信息，如UA头部等</span><br></pre></td></tr></table></figure>
<p>常用的响应头部（部分）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: 服务器端允许的请求Headers</span><br><span class="line">Access-Control-Allow-Methods: 服务器端允许的请求方法</span><br><span class="line">Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）</span><br><span class="line">Content-Type：服务端返回的实体内容的类型</span><br><span class="line">Date：数据从服务器发送的时间</span><br><span class="line">Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line">Last-Modified：请求资源的最后修改时间</span><br><span class="line">Expires：应该在什么时候认为文档已经过期,从而不再缓存它</span><br><span class="line">Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</span><br><span class="line">ETag：请求变量的实体标签的当前值</span><br><span class="line">Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</span><br><span class="line">Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</span><br><span class="line">Server：服务器的一些相关信息</span><br></pre></td></tr></table></figure>
<p>一般来说，请求头部和响应头部是匹配分析的。</p>
<p>譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错</p>
<p>譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误</p>
<p>譬如，在使用缓存时，请求头部的<code>If-Modified-Since</code>、<code>If-None-Match</code>分别和响应头部的<code>Last-Modified</code>、<code>ETag</code>对应</p>
<p>还有很多的分析方法，这里不一一赘述</p>
<p><strong>请求/响应实体</strong></p>
<p>http请求时，除了头部，还有消息实体，一般来说</p>
<p>请求实体中会将一些需要的参数都放入进入（用于post请求）。</p>
<p>譬如实体中可以放参数的序列化形式（<code>a=1&amp;b=2</code>这种），或者直接放表单对象（<code>Form Data</code>对象，上传时可以夹杂参数以及文件），等等</p>
<p>而一般响应实体中，就是放服务端需要传给客户端的内容</p>
<p>一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。</p>
<p><strong>CRLF</strong></p>
<p>CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在</p>
<p>请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔</p>
<p>一般来说（分隔符类别）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRLF-&gt;Windows-style</span><br><span class="line">LF-&gt;Unix Style</span><br><span class="line">CR-&gt;Mac Style</span><br></pre></td></tr></table></figure></p>
<h4 id="cookie以及优化"><a href="#cookie以及优化" class="headerlink" title="cookie以及优化"></a>cookie以及优化</h4><p>cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。</p>
<p>场景如下（简述）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在登陆页面，用户登陆了</span><br><span class="line"></span><br><span class="line">此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）</span><br><span class="line"></span><br><span class="line">然后会有一个sessionid（相当于是服务端的这个session对应的key）</span><br><span class="line"></span><br><span class="line">然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx</span><br><span class="line"></span><br><span class="line">然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br></pre></td></tr></table></figure>
<p>上述就是cookie的常用场景简述（当然了，实际情况下得考虑更多因素）</p>
<p>一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置<code>httponly</code>（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）</p>
<p>另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。</p>
<p>譬如以下场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line"></span><br><span class="line">然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源）</span><br><span class="line"></span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line"></span><br><span class="line">也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line"></span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure>
<p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p>
<ul>
<li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li>
<li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的cookie的，所以就避免了浪费</li>
</ul>
<p>说到了多域名拆分，这里再提一个问题，那就是：</p>
<ul>
<li>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）</li>
<li>此时就需要用到一种优化方案：<code>dns-prefetch</code>（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</li>
</ul>
<h4 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h4><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持），<br>而且gzip压缩效率很好（高达70%左右）</p>
<p>然后gzip一般是由<code>apache</code>、<code>tomcat</code>等web服务器开启</p>
<p>当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）</p>
<p>所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的，非常方便。</p>
<h4 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h4><p>首先看<code>tcp/ip</code>层面的定义：</p>
<ul>
<li>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li>
<li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li>
</ul>
<p>然后在http层面：</p>
<ul>
<li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li>
<li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li>
</ul>
<p>注意： <strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</strong></p>
<h4 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h4><p>http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）</p>
<p>然后简述下http2.0与http1.1的显著不同点：</p>
<ul>
<li>http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li>
<li>http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li>
</ul>
<p>所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）</p>
<p>然后简述下http2.0的一些特性：</p>
<ul>
<li>多路复用（即一个tcp/ip连接可以请求多个资源）</li>
<li>首部压缩（http头部压缩，减少体积）</li>
<li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li>
<li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li>
<li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li>
</ul>
<h4 id="https"><a href="#https" class="headerlink" title="https"></a>https</h4><p>https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。</p>
<p>简单来看，https与http的区别就是： <strong>在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong></p>
<p>一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）</p>
<p>一般来说，主要关注的就是SSL/TLS的握手流程，如下（简述）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 </span><br><span class="line"></span><br><span class="line">2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器</span><br><span class="line">（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</span><br><span class="line"></span><br><span class="line">3. 浏览器收到服务端的证书后</span><br><span class="line"></span><br><span class="line">    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</span><br><span class="line"></span><br><span class="line">    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。</span><br><span class="line"></span><br><span class="line">    - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`</span><br><span class="line"></span><br><span class="line">    - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。 </span><br><span class="line"></span><br><span class="line">4. 服务端收到浏览器的回复</span><br><span class="line"></span><br><span class="line">    - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`</span><br><span class="line"></span><br><span class="line">    - 和浏览器相同规则生成`session key`</span><br><span class="line"></span><br><span class="line">    - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</span><br><span class="line"></span><br><span class="line">    - 使用`session key`加密一段握手消息，发送给浏览器</span><br><span class="line"></span><br><span class="line">5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，</span><br></pre></td></tr></table></figure>
<p><strong>之后所有的https通信数据将由之前浏览器生成的<code>session key</code>并利用对称加密算法进行加密</strong>。</p>
<h3 id="单独拎出来的缓存问题，http的缓存"><a href="#单独拎出来的缓存问题，http的缓存" class="headerlink" title="单独拎出来的缓存问题，http的缓存"></a>单独拎出来的缓存问题，http的缓存</h3><p>前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的</p>
<h4 id="强缓存与弱缓存"><a href="#强缓存与弱缓存" class="headerlink" title="强缓存与弱缓存"></a>强缓存与弱缓存</h4><p>缓存可以简单的划分成两种类型：<code>强缓存</code>（<code>200 from cache</code>）与<code>协商缓存</code>（<code>304</code>）</p>
<p>区别简述如下：</p>
<ul>
<li>强缓存（<code>200 from cache</code>）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求</li>
<li>协商缓存（<code>304</code>）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li>
</ul>
<p>对于协商缓存，使用<code>Ctrl + F5</code>强制刷新可以使得缓存无效</p>
<p>但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）</p>
<h4 id="缓存头部简述"><a href="#缓存头部简述" class="headerlink" title="缓存头部简述"></a>缓存头部简述</h4><p>上述提到了强缓存和协商缓存，那它们是怎么区分的呢？</p>
<p>答案是通过不同的http头部控制</p>
<p>先看下这几个头部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires</span><br></pre></td></tr></table></figure>
<p>这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。</p>
<p>属于强缓存控制的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）Cache-Control/Max-Age</span><br><span class="line">（http1.0）Pragma/Expires</span><br></pre></td></tr></table></figure>
<p>注意：<strong><code>Max-Age</code>不是一个头部，它是<code>Cache-Control</code>头部的值</strong></p>
<p>属于协商缓存控制的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）If-None-Match/E-tag</span><br><span class="line">（http1.0）If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure>
<p>可以看到，上述有提到<code>http1.1</code>和<code>http1.0</code>，这些不同的头部是属于不同http时期的</p>
<p>再提一点，其实HTML页面中也有一个meta标签可以控制缓存方案-<code>Pragma</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐</p>
<h4 id="头部的区别"><a href="#头部的区别" class="headerlink" title="头部的区别"></a>头部的区别</h4><p>首先明确，http的发展是从http1.0到http1.1</p>
<p>而在http1.1中，出了一些新内容，弥补了http1.0的不足。</p>
<p><strong>http1.0中的缓存控制：</strong></p>
<ul>
<li><code>Pragma</code>：严格来说，它不属于专门的缓存控制头部，但是它设置<code>no-cache</code>时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）</li>
<li><code>Expires</code>：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如<code>Expires：Fri, 30 Oct 1998 14:19:41</code></li>
<li><code>If-Modified-Since/Last-Modified</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-Modified-Since</code>，而服务端的是<code>Last-Modified</code>，它的作用是，在发起请求时，如果<code>If-Modified-Since</code>和<code>Last-Modified</code>匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。<code>Last-Modified</code>，顾名思义，指的是文件最后的修改时间，而且只能精确到<code>1s</code>以内</li>
</ul>
<p><strong>http1.1中的缓存控制：</strong></p>
<ul>
<li><code>Cache-Control</code>：缓存控制头部，有no-cache、max-age等多种取值</li>
<li><code>Max-Age</code>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如<code>Cache-Control: max-age=3600</code>，而且它值得是绝对时间，由浏览器自己计算</li>
<li><code>If-None-Match/E-tag</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-None-Match</code>，而服务端的是<code>E-tag</code>，同样，发出请求后，如果<code>If-None-Match</code>和<code>E-tag</code>匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于<code>FileEtag INode Mtime Size</code>生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li>
</ul>
<p><strong>Max-Age相比Expires？</strong></p>
<p><code>Expires</code>使用的是服务器端的时间</p>
<p>但是有时候会有这样一种情况-客户端时间和服务端不同步</p>
<p>那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期</p>
<p>所以一般http1.1后不推荐使用<code>Expires</code></p>
<p>而<code>Max-Age</code>使用的是客户端本地时间的计算，因此不会有这个问题</p>
<p>因此推荐使用<code>Max-Age</code>。</p>
<p>注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。</p>
<p><strong>E-tag相比Last-Modified？</strong></p>
<p><code>Last-Modified</code>：</p>
<ul>
<li>表明服务端的文件最后何时改变的</li>
<li>它有一个缺陷就是只能精确到1s，</li>
<li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li>
</ul>
<p>而<code>E-tag</code>：</p>
<ul>
<li>是一种指纹机制，代表文件相关指纹</li>
<li>只有文件变才会变，也只要文件变就会变，</li>
<li>也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</li>
</ul>
<p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code></p>
<p>各大缓存头部的整体关系如下图<br><img src="https://sfault-image.b0.upaiyun.com/107/814/107814026-5aa5cafca80bf_articlex" alt=""></p>
<p><em>相关文章：<a href="https://segmentfault.com/a/1190000008377508?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly#articleHeader0" target="_blank" rel="noopener">浏览器缓存</a></em></p>
<h3 id="解析页面流程"><a href="#解析页面流程" class="headerlink" title="解析页面流程"></a>解析页面流程</h3><h4 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h4><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 解析HTML，构建DOM树</span><br><span class="line"></span><br><span class="line">2. 解析CSS，生成CSS规则树</span><br><span class="line"></span><br><span class="line">3. 合并DOM树和CSS规则，生成render树</span><br><span class="line"></span><br><span class="line">4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算</span><br><span class="line"></span><br><span class="line">5. 绘制render树（paint），绘制页面像素信息</span><br><span class="line"></span><br><span class="line">6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</span><br></pre></td></tr></table></figure>
<p><img src="https://sfault-image.b0.upaiyun.com/137/309/1373095523-5a658fc12f1fd_articlex" alt="渲染步骤"></p>
<h4 id="HTML解析，构建DOM"><a href="#HTML解析，构建DOM" class="headerlink" title="HTML解析，构建DOM"></a>HTML解析，构建DOM</h4><p>整个渲染步骤中，HTML解析是第一步。</p>
<p>简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong></p>
<p>但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。</p>
<p>解析HTML到构建出DOM当然过程可以简述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure>
<p>譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critical Path&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器的处理如下：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/236/309/2363096142-5aa5cafc74a50_articlex" alt=""></p>
<p>列举其中的一些重点过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</span><br><span class="line"></span><br><span class="line">2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</span><br><span class="line"></span><br><span class="line">3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</span><br><span class="line"></span><br><span class="line">4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</span><br><span class="line">例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象</span><br></pre></td></tr></table></figure>
<p>最后的DOM树如下：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/226/254/2262547194-5aa5cafc2e219_articlex" alt=""></p>
<h4 id="生成CSS规则"><a href="#生成CSS规则" class="headerlink" title="生成CSS规则"></a>生成CSS规则</h4><p>同理，CSS规则树的生成也是类似。简述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure>
<p>譬如<code>style.css</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure>
<p>那么最终的CSSOM树就是：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/324/599/3245996893-5aa5cafbecf07_articlex" alt=""></p>
<h4 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h4><p>当DOM树和CSSOM都有了后，就要开始构建渲染树了</p>
<p>一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应</p>
<p>因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者<code>display: none</code>等</p>
<p>整体来说可以看图：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/316/642/316642185-5aa5cafc36e11_articlex" alt=""></p>
<h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>有了render树，接下来就是开始渲染，基本流程如下：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/588/361/588361506-5aa5cafbe158d_articlex" alt=""></p>
<p>图中重要的四个步骤就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 计算CSS样式</span><br><span class="line"></span><br><span class="line">2. 构建渲染树</span><br><span class="line"></span><br><span class="line">3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性</span><br><span class="line"></span><br><span class="line">4. 绘制，将图像绘制出来</span><br></pre></td></tr></table></figure>
<p>然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）</p>
<p>这里Layout和Repaint的概念是有区别的：</p>
<ul>
<li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li>
<li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li>
</ul>
<p>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，<br>所以优化方案中一般都包括，尽量避免回流。</p>
<p><strong>什么会引起回流？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.页面渲染初始化</span><br><span class="line"></span><br><span class="line">2.DOM结构改变，比如删除了某个节点</span><br><span class="line"></span><br><span class="line">3.render树变化，比如减少了padding</span><br><span class="line"></span><br><span class="line">4.窗口resize</span><br><span class="line"></span><br><span class="line">5.最复杂的一种：获取某些属性，引发回流，</span><br><span class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，</span><br><span class="line">但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （1）offset(Top/Left/Width/Height)</span><br><span class="line">     (2) scroll(Top/Left/Width/Height)</span><br><span class="line">     (3) cilent(Top/Left/Width/Height)</span><br><span class="line">     (4) width,height</span><br><span class="line">     (5) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure>
<p>回流一定伴随着重绘，重绘却可以单独出现</p>
<p>所以一般会有一些优化方案，如：</p>
<ul>
<li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li>
<li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li>
<li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li>
<li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li>
</ul>
<p><strong>注意：改变字体大小会引发回流</strong></p>
<p>再来看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line"></span><br><span class="line">s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line">s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line">s.color = &quot;blue&quot;; // 再一次重绘</span><br><span class="line">s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘</span><br><span class="line">s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line">// 添加node，再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&apos;abc!&apos;));</span><br></pre></td></tr></table></figure>
<h4 id="简单层与复合层"><a href="#简单层与复合层" class="headerlink" title="简单层与复合层"></a>简单层与复合层</h4><p>上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。</p>
<p>这里不展开，进简单介绍下：</p>
<ul>
<li>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的</li>
<li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li>
<li>复合图层之间的绘制互不干扰，由GPU直接控制</li>
<li>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li>
</ul>
<p>更多参考：</p>
<p><a href="https://segmentfault.com/a/1190000012925872#articleHeader16" target="_blank" rel="noopener">普通图层和复合图层</a></p>
<h4 id="Chrome中的调试"><a href="#Chrome中的调试" class="headerlink" title="Chrome中的调试"></a>Chrome中的调试</h4><p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/138/671/1386713703-5aa5cafbad312_articlex" alt=""><br><img src="https://sfault-image.b0.upaiyun.com/169/903/1699039536-5aa5cafb9b136_articlex" alt=""></p>
<h4 id="资源外链的下载"><a href="#资源外链的下载" class="headerlink" title="资源外链的下载"></a>资源外链的下载</h4><p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了</p>
<p>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p>
<ul>
<li>CSS样式资源</li>
<li>JS脚本资源</li>
<li>img图片类资源</li>
</ul>
<p><strong>遇到外链时的处理</strong></p>
<p>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</p>
<p><strong>遇到CSS样式资源</strong></p>
<p>CSS资源的处理有几个特点：</p>
<ul>
<li>CSS下载时异步，不会阻塞浏览器构建DOM树</li>
<li>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li>
<li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li>
</ul>
<p><strong>遇到JS脚本资源</strong></p>
<p>JS脚本资源的处理有几个特点：</p>
<ul>
<li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li>
<li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li>
<li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li>
</ul>
<p><img src="https://sfault-image.b0.upaiyun.com/215/179/2151798436-59da4801c6772" alt="JS脚本解析"></p>
<p>注意，defer和async是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong></p>
<p>简单的说（不展开）：</p>
<ul>
<li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li>
<li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了<code>body</code>后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li>
</ul>
<p><strong>遇到img图片类资源</strong></p>
<p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p>
<h4 id="loaded和domcontentloaded"><a href="#loaded和domcontentloaded" class="headerlink" title="loaded和domcontentloaded"></a>loaded和domcontentloaded</h4><p>简单的对比：</p>
<ul>
<li>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li>
<li>load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li>
</ul>
<p><em>相关文章：<a href="https://segmentfault.com/a/1190000010298038" target="_blank" rel="noopener">浏览器渲染页面过程与页面优化</a>（更详细，而且参考链接很重要）</em></p>
<h3 id="CSS的可视化格式模型"><a href="#CSS的可视化格式模型" class="headerlink" title="CSS的可视化格式模型"></a>CSS的可视化格式模型</h3><p><strong>这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源</strong></p>
<p>前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： <strong>CSS的可视化格式模型</strong></p>
<p>先了解：</p>
<ul>
<li>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li>
<li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局</li>
<li>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</li>
</ul>
<p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong></p>
<p>关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">包含块（Containing Block）</span><br><span class="line">控制框（Controlling Box）</span><br><span class="line">BFC（Block Formatting Context）</span><br><span class="line">IFC（Inline Formatting Context）</span><br><span class="line">定位体系</span><br><span class="line">浮动</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的</p>
<h3 id="包含块（Containing-Block）"><a href="#包含块（Containing-Block）" class="headerlink" title="包含块（Containing Block）"></a>包含块（Containing Block）</h3><p>一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。</p>
<p>元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系</p>
<p>譬如：</p>
<ul>
<li>根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li>
<li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li>
<li>fixed的包含块是当前可视窗口</li>
<li><p>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建</p>
<ul>
<li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li>
<li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li>
</ul>
</li>
</ul>
<h4 id="控制框（Controlling-Box）"><a href="#控制框（Controlling-Box）" class="headerlink" title="控制框（Controlling Box）"></a>控制框（Controlling Box）</h4><p>块级元素和块框以及行内元素和行框的相关概念</p>
<p><strong>块框:</strong></p>
<ul>
<li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li>
<li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li>
</ul>
<p>关于<strong>匿名块框</strong>的生成，示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">Some text</span><br><span class="line">&lt;P&gt;More text</span><br><span class="line">&lt;/DIV&gt;</span><br></pre></td></tr></table></figure>
<p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是<code>IFC</code>中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）</p>
<p>换句话说:</p>
<p><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong></p>
<p><strong>行内框：</strong></p>
<ul>
<li>一个行内元素生成一个行内框</li>
<li>行内元素能排在一行，允许左右有其它元素</li>
</ul>
<p>关于<strong>匿名行内框</strong>的生成，示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;P&gt;Some &lt;EM&gt;emphasized&lt;/EM&gt; text&lt;/P&gt;</span><br></pre></td></tr></table></figure>
<p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some</code>，<code>text</code>，此时会专门为这些文本生成匿名行内框</p>
<p><strong>display属性的影响</strong></p>
<p><code>display</code>的几个属性也可以影响不同框的生成：</p>
<ul>
<li><code>block</code>，元素生成一个块框</li>
<li><code>inline</code>，元素产生一个或多个的行内框</li>
<li><code>inline-block</code>，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）</li>
<li><code>none</code>，不生成框，不再格式化结构中，当然了，另一个<code>visibility: hidden</code>则会产生一个不可见的框</li>
</ul>
<p>总结：</p>
<ul>
<li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li>
<li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列</li>
</ul>
<h4 id="BFC（Block-Formatting-Context）"><a href="#BFC（Block-Formatting-Context）" class="headerlink" title="BFC（Block Formatting Context）"></a>BFC（Block Formatting Context）</h4><p>FC（格式上下文）？</p>
<p>FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FC像是一个大箱子，里面装有很多元素</span><br><span class="line"></span><br><span class="line">箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）</span><br><span class="line"></span><br><span class="line">内部的规则可以是：如何定位，宽高计算，margin折叠等等</span><br></pre></td></tr></table></figure>
<p>不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC</p>
<p><strong>注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则</strong></p>
<p><strong>BFC规则：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在块格式化上下文中</span><br><span class="line"></span><br><span class="line">每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）</span><br><span class="line"></span><br><span class="line">即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）</span><br><span class="line"></span><br><span class="line">除非这个元素也创建了一个新的BFC</span><br></pre></td></tr></table></figure>
<p>总结几点BFC特点：</p>
<ol>
<li>内部<code>box</code>在垂直方向，一个接一个的放置</li>
<li>box的垂直方向由<code>margin</code>决定，属于同一个BFC的两个box间的margin会重叠</li>
<li>BFC区域不会与<code>float box</code>重叠（可用于排版)</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li>
<li>计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）</li>
</ol>
<p>如何触发BFC？</p>
<ol>
<li>根元素</li>
<li><code>float</code>属性不为<code>none</code></li>
<li><code>position</code>为<code>absolute</code>或<code>fixed</code></li>
<li><code>display</code>为<code>inline-block</code>, <code>flex</code>, <code>inline-flex</code>，<code>table</code>，<code>table-cell</code>，<code>table-caption</code></li>
<li><code>overflow</code>不为<code>visible</code></li>
</ol>
<p>这里提下，<code>display: table</code>，它本身不产生BFC，但是它会产生匿名框（包含<code>display: table-cell</code>的框），而这个匿名框产生BFC</p>
<p>更多请自行网上搜索</p>
<h4 id="IFC（Inline-Formatting-Context）"><a href="#IFC（Inline-Formatting-Context）" class="headerlink" title="IFC（Inline Formatting Context）"></a>IFC（Inline Formatting Context）</h4><p>IFC即行内框产生的格式上下文</p>
<p><strong>IFC规则</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在行内格式化上下文中</span><br><span class="line"></span><br><span class="line">框一个接一个地水平排列，起点是包含块的顶部。</span><br><span class="line"></span><br><span class="line">水平方向上的 margin，border 和 padding 在框之间得到保留</span><br><span class="line"></span><br><span class="line">框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</span><br></pre></td></tr></table></figure>
<p><strong>行框</strong></p>
<p><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong></p>
<p>行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定</p>
<p>行框的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）</span><br><span class="line"></span><br><span class="line">行框在堆叠时没有垂直方向上的分割且永不重叠</span><br><span class="line"></span><br><span class="line">行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）</span><br><span class="line"></span><br><span class="line">行框的左边接触到其包含块的左边，右边接触到其包含块的右边。</span><br></pre></td></tr></table></figure>
<p><strong>结合补充下IFC规则：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">浮动元素可能会处于包含块边缘和行框边缘之间</span><br><span class="line"></span><br><span class="line">尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化</span><br><span class="line"></span><br><span class="line">同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）</span><br><span class="line"></span><br><span class="line">当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性</span><br><span class="line"></span><br><span class="line">空的行内框应该被忽略</span><br><span class="line"></span><br><span class="line">即不包含文本，保留空白符，margin/padding/border非0的行内元素，</span><br><span class="line">以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，</span><br><span class="line">并且不是以换行结束的行框，</span><br><span class="line">必须被当作零高度行框对待</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>行内元素总是会应用IFC渲染规则</li>
<li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li>
<li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li>
<li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li>
<li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li>
</ul>
<p>相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件）</p>
<p>但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>当然还有有一些其它内容：</p>
<ul>
<li>譬如常规流，浮动，绝对定位等区别</li>
<li>譬如浮动元素不包含在常规流中</li>
<li>譬如相对定位，绝对定位，<code>Fixed</code>定位等区别</li>
<li>譬如<code>z-index</code>的分层显示机制等</li>
</ul>
<p>这里不一一展开，更多请参考：</p>
<p><a href="http://bbs.csdn.net/topics/340204423" target="_blank" rel="noopener">http://bbs.csdn.net/topics/340204423</a></p>
<h3 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h3><p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）</p>
<h4 id="JS的解释阶段"><a href="#JS的解释阶段" class="headerlink" title="JS的解释阶段"></a>JS的解释阶段</h4><p>首先得明确： <strong>JS是解释型语音，所以它无需提前编译，而是由解释器实时运行</strong></p>
<p>引擎对JS的处理过程可以简述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</span><br><span class="line"></span><br><span class="line">2. 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</span><br><span class="line"></span><br><span class="line">3. 使用翻译器（translator），将代码转为字节码（bytecode）</span><br><span class="line"></span><br><span class="line">4. 使用字节码解释器（bytecode interpreter），将字节码转为机器码</span><br></pre></td></tr></table></figure>
<p>最终计算机执行的就是机器码。</p>
<p>为了提高运行速度，现代浏览器一般采用即时编译（<code>JIT-Just In Time compiler</code>）</p>
<p>即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（<code>inline cache</code>）</p>
<p>这样整个程序的运行速度能得到显著提升。</p>
<p>而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）</p>
<p>总结起来可以认为是： <strong>核心的<code>JIT</code>编译器将源码编译成机器码运行</strong></p>
<h4 id="JS的预处理阶段"><a href="#JS的预处理阶段" class="headerlink" title="JS的预处理阶段"></a>JS的预处理阶段</h4><p>上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段<br>（譬如变量提升，分号补全等）</p>
<p>预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分：</p>
<p><strong>分号补全</strong></p>
<p>JS执行是需要分号的，但为什么以下语句却可以正常运行呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;a&apos;)</span><br><span class="line">console.log(&apos;b&apos;)</span><br></pre></td></tr></table></figure>
<p>原因就是JS解释器有一个<a href="http://inimino.org/~inimino/blog/javascript_semicolons" target="_blank" rel="noopener">Semicolon Insertion</a>规则，它会按照一定规则，在适当的位置补充分号</p>
<p>譬如列举几条自动加分号的规则：</p>
<ul>
<li>当有换行符（包括含有换行符的多行注释），并且下一个<code>token</code>没法跟前面的语法匹配时，会自动补分号。</li>
<li>当有<code>}</code>时，如果缺少分号，会补分号。</li>
<li>程序源代码结束时，如果缺少分号，会补分号。</li>
</ul>
<p>于是，上述的代码就变成了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;a&apos;);</span><br><span class="line">console.log(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>所以可以正常运行</p>
<p>当然了，这里有一个经典的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return</span><br><span class="line">    &#123;</span><br><span class="line">        a: &apos;a&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于分号补全机制，所以它变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return;</span><br><span class="line">    &#123;</span><br><span class="line">        a: &apos;a&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以运行后是<code>undefined</code></p>
<p><strong>变量提升</strong></p>
<p>一般包括函数提升和变量提升</p>
<p>譬如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">b();</span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br></pre></td></tr></table></figure>
<p>经过变量提升后，就变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br><span class="line">a = 1;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>
<p>这里没有展开，其实展开也可以牵涉到很多内容的</p>
<p>譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及es6中let有关的临时死区等</p>
<h4 id="JS的执行阶段"><a href="#JS的执行阶段" class="headerlink" title="JS的执行阶段"></a>JS的执行阶段</h4><p>此阶段的内容中的图片来源：<a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html" target="_blank" rel="noopener">深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇）</a></p>
<p>解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p>
<ul>
<li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li>
<li>VO（变量对象）和AO（活动对象）</li>
<li>作用域链</li>
<li>this机制等</li>
</ul>
<p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性</p>
<p><strong>执行上下文简单解释</strong></p>
<ul>
<li>JS有<code>执行上下文</code>）</li>
<li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入执行栈栈顶（不可被弹出）</li>
<li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部</li>
<li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。</li>
<li>这样依次执行（最终都会回到全局执行上下文）</li>
</ul>
<p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收</p>
<p><img src="https://sfault-image.b0.upaiyun.com/620/422/620422871-570d14feaf681_articlex" alt=""></p>
<p>然后执行上下文与VO，作用域链，this的关系是：</p>
<p>每一个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(<code>Variable object，VO</code>)</li>
<li>作用域链(<code>Scope chain</code>)</li>
<li><code>this</code></li>
</ul>
<p><img src="https://sfault-image.b0.upaiyun.com/181/531/1815319493-570948eed9b27_articlex" alt=""></p>
<p><strong>VO与AO</strong></p>
<p>VO是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong></p>
<p>AO（<code>activation object</code>)，当函数被调用者激活，AO就被创建了</p>
<p>可以理解为：</p>
<ul>
<li>在函数上下文中：<code>VO === AO</code></li>
<li>在全局上下文中：<code>VO === this === global</code></li>
</ul>
<p>总的来说，VO中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）</p>
<p><strong>作用域链</strong></p>
<p>它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。</p>
<p>譬如流程简述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在函数上下文中，查找一个变量foo</span><br><span class="line"></span><br><span class="line">如果函数的VO中找到了，就直接使用</span><br><span class="line"></span><br><span class="line">否则去它的父级作用域链中（__parent__）找</span><br><span class="line"></span><br><span class="line">如果父级中没找到，继续往上找</span><br><span class="line"></span><br><span class="line">直到全局上下文中也没找到就报错</span><br></pre></td></tr></table></figure>
<p><img src="https://sfault-image.b0.upaiyun.com/171/264/1712643983-570d14ffae847_articlex" alt=""></p>
<p><strong>this指针</strong></p>
<p>这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分</p>
<p>注意：<strong>this是执行上下文环境的一个属性，而不是某个变量对象的属性</strong></p>
<p>因此:</p>
<ul>
<li>this是没有一个类似搜寻变量的过程</li>
<li>当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li>
<li>this的值只取决中进入上下文时的情况</li>
</ul>
<p>所以经典的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var baz = 200;</span><br><span class="line">var bar = &#123;</span><br><span class="line">    baz: 100,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        console.log(this.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var foo = bar.foo;</span><br><span class="line"></span><br><span class="line">// 进入环境：global</span><br><span class="line">foo(); // 200，严格模式中会报错，Cannot read property &apos;baz&apos; of undefined</span><br><span class="line"></span><br><span class="line">// 进入环境：global bar</span><br><span class="line">bar.foo(); // 100</span><br></pre></td></tr></table></figure>
<p>就要明白了上面this的介绍，上述例子很好理解</p>
<p>更多参考：</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html" target="_blank" rel="noopener">深入理解JavaScript系列（13）：This? Yes,this!</a></p>
<h4 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h4><p>JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。</p>
<p>一般来说，垃圾处理器有自己的回收策略。</p>
<p>譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）</p>
<p>常用的两种垃圾回收规则是：</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<p>Javascript引擎基础GC方案是（<code>simple GC</code>）：<code>mark and sweep</code>（标记清除），简单解释如下：</p>
<ol>
<li>遍历所有可访问的对象。</li>
<li>回收已不可访问的对象。</li>
</ol>
<p>譬如：（出自javascript高程）</p>
<blockquote>
<p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。</p>
<p>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</p>
<p>而当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</p>
<p>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。</p>
<p>而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</p>
<p>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
</blockquote>
<p>关于引用计数，简单点理解：</p>
<p><strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数<code>+1</code>，减持时<code>-1</code>，下次垃圾回收器会回收次数为<code>0</code>的值的内存（当然了，容易出循环引用的bug）</strong></p>
<p><strong>GC的缺陷</strong></p>
<p>和其他语言一样，javascript的GC策略也无法避免一个问题： <strong>GC时，停止响应其他操作</strong></p>
<p>这是为了安全考虑。</p>
<p>而Javascript的GC在<code>100ms</code>甚至以上</p>
<p>对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。</p>
<p>这就是引擎需要优化的点： <strong>避免GC造成的长时间停止响应。</strong></p>
<p><strong>GC优化策略</strong></p>
<p>这里介绍常用到的：<strong>分代回收（Generation GC）</strong></p>
<p>目的是通过区分“临时”与“持久”对象:</p>
<ul>
<li>多回收“临时对象”区（<code>young generation</code>）</li>
<li>少回收“持久对象”区（<code>tenured generation</code>）</li>
<li>减少每次需遍历的对象，从而减少每次GC的耗时。</li>
</ul>
<p>像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）</p>
<p>更多可以参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/33816534" target="_blank" rel="noopener">V8 内存浅析</a></p>
<h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><h4 id="可以提到跨域"><a href="#可以提到跨域" class="headerlink" title="可以提到跨域"></a>可以提到跨域</h4><p>譬如发出网络请求时，会用AJAX，如果接口跨域，就会遇到跨域问题</p>
<p>可以参考：</p>
<p><a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a></p>
<h4 id="可以提到web安全"><a href="#可以提到web安全" class="headerlink" title="可以提到web安全"></a>可以提到web安全</h4><p>譬如浏览器在解析HTML时，有<code>XSSAuditor</code>，可以延伸到web安全相关领域</p>
<p>可以参考：</p>
<p><a href="https://segmentfault.com/a/1190000012693772" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系。</a></p>
<h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>如可以提到<code>viewport</code>概念，讲讲物理像素，逻辑像素，CSS像素等概念</p>
<p>如熟悉Hybrid开发的话可以提及一下Hybrid相关内容以及优化</p>
<p>…</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述这么多内容，目的是：<strong>梳理出自己的知识体系</strong></p>
<p>本文由于是前端向，所以知识梳理时有重点，很多其它的知识点都简述或略去了，重点介绍的模块总结：</p>
<ul>
<li>浏览器的进程/线程模型、JS运行机制（这一块的详细介绍链接到了另一篇文章）</li>
<li>http规范（包括报文结构，头部，优化，http2.0，https等）</li>
<li>http缓存（单独列出来，因为它很重要）</li>
<li>页面解析流程（HTML解析，构建DOM，生成CSS规则，构建渲染树，渲染流程，复合层的合成，外链的处理等）</li>
<li>JS引擎解析过程（包括解释阶段，预处理阶段，执行阶段，包括执行上下文、VO、作用域链、this、回收机制等）</li>
<li>跨域相关，web安全单独链接到了具体文章，其它如CSS盒模型，viewport等仅是提及概念</li>
</ul>
<p>关于本文的价值？</p>
<p><strong>本文是个人阶段性梳理知识体系的成果</strong>，然后加以修缮后发布成文章，因此并不确保适用于所有人员</p>
<p>但是，个人认为本文还是有一定参考价值的</p>
<h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>还是那句话：<strong>知识要形成体系</strong></p>
<p>梳理出知识体系后，有了一个骨架，知识点不易遗忘，而且学习新知识时也会更加迅速，更重要的是容易举一反三，可以由一个普通的问题，深挖拓展到底层原理</p>
<p>前端知识是无穷无尽的，本文也仅仅是简单梳理出一个承载知识体系的骨架而已，更多的内容仍然需要不断学习，积累</p>
<p>另外，本文结合<a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a>这篇文章，更佳噢！</p>
<h2 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h2><ol>
<li><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2014/05/what-happen/</a></li>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li>
<li><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9666.html</a></li>
<li><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/" target="_blank" rel="noopener">http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/</a></li>
<li><a href="https://blog.csdn.net/dojiangv/article/details/51794535" target="_blank" rel="noopener">https://blog.csdn.net/dojiangv/article/details/51794535</a></li>
<li><a href="https://bbs.csdn.net/topics/340204423" target="_blank" rel="noopener">https://bbs.csdn.net/topics/340204423</a></li>
<li><a href="https://segmentfault.com/a/1190000004246731" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004246731</a></li>
<li><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2014/05/what-happen/</a></li>
<li><a href="http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html" target="_blank" rel="noopener">http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html</a></li>
<li><a href="https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html" target="_blank" rel="noopener">https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html</a></li>
<li><a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html</a></li>
</ol>

      
    </div>

    
    
      <div>
    
        <div style="text-align:center;color: #555;font-size:14px;">-------------The End-------------</div>
    
</div>
    
    
    
    
    <div>
          
            
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/">基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Alvabill 的个人博客">Alvabill</a></p>
  <p><span>发布时间:</span>2018年03月29日 - 17:03</p>
  <p><span>最后更新:</span>2018年09月07日 - 13:09</p>
  <p><span>原始链接:</span><a href="/基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/" title="基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建">http://alvabill.ml/基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://alvabill.ml/基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
	});
    });  
</script>

          
    </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="http://p3dm71oa7.bkt.clouddn.com/wcpay.png" alt="Alvabill WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="http://p3dm71oa7.bkt.clouddn.com/zfbpay.jpg" alt="Alvabill Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          
            <a href="/tags/HTTP/" rel="tag"><i class="fa fa-tag"></i> HTTP</a>
          
            <a href="/tags/浏览器/" rel="tag"><i class="fa fa-tag"></i> 浏览器</a>
          
            <a href="/tags/CSS/" rel="tag"><i class="fa fa-tag"></i> CSS</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
            <div id="wpac-rating"></div>
          </div>
        

        

        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/最全Javascript数据类型解析/" rel="next" title="最全Javascript数据类型解析">
                <i class="fa fa-chevron-left"></i> 最全Javascript数据类型解析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/前端复习汇总/" rel="prev" title="前端复习汇总">
                前端复习汇总 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>

  
    <div style="text-align: center;">
      <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5a7327e2ab18bb74" async = "async" ></script>
</div>

    </div>
  

  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzc1MC8xMDMwNA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Alvabill" />
            
              <p class="site-author-name" itemprop="name">Alvabill</p>
              <p class="site-description motion-element" itemprop="description">Alvabill个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Alvabill" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.freecodecamp.cn/alvabill" target="_blank" title="fcc" rel="external nofollow"><i class="fa fa-fw fa-free-code-camp"></i>fcc</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/439a6eee60e1" target="_blank" title="简书" rel="external nofollow"><i class="fa fa-fw fa-book"></i>简书</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://blog.csdn.net/weixin_38796712" target="_blank" title="CSDN" rel="external nofollow"><i class="fa fa-fw fa-rotate-right"></i>CSDN</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://juejin.im/user/5a745af5f265da4e8b2fb184" target="_blank" title="掘金" rel="external nofollow"><i class="fa fa-fw fa-angle-double-down"></i>掘金</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://segmentfault.com/u/alvabill" target="_blank" title="segmentfault" rel="external nofollow"><i class="fa fa-fw fa-gripfire"></i>segmentfault</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank">Web前端导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.chuangzaoshi.com/code" title="创造狮导航" target="_blank">创造狮导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.36zhen.com/t?id=3448" title="前端书籍资料" target="_blank">前端书籍资料</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://e.xitu.io/" title="掘金酱" target="_blank">掘金酱</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.v2ex.com/" title="V2EX" target="_blank">V2EX</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.v2ex.com/" title="印记中文" target="_blank">印记中文</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#梳理主干流程"><span class="nav-number">3.</span> <span class="nav-text">梳理主干流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#细节内容填充"><span class="nav-number">4.</span> <span class="nav-text">细节内容填充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从浏览器接收url到开启网络请求线程"><span class="nav-number">4.1.</span> <span class="nav-text">从浏览器接收url到开启网络请求线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多进程的浏览器"><span class="nav-number">4.1.1.</span> <span class="nav-text">多进程的浏览器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程的浏览器内核"><span class="nav-number">4.1.2.</span> <span class="nav-text">多线程的浏览器内核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析URL"><span class="nav-number">4.1.3.</span> <span class="nav-text">解析URL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开辟网络请求线程"><span class="nav-number">4.1.4.</span> <span class="nav-text">开辟网络请求线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开启网络线程到发出一个完整的http请求"><span class="nav-number">4.2.</span> <span class="nav-text">开启网络线程到发出一个完整的http请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS查询"><span class="nav-number">4.2.1.</span> <span class="nav-text">DNS查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-ip请求"><span class="nav-number">4.2.2.</span> <span class="nav-text">tcp/ip请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五层因特网协议栈"><span class="nav-number">4.2.3.</span> <span class="nav-text">五层因特网协议栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从服务器接收到请求到对应后台接收到请求"><span class="nav-number">4.3.</span> <span class="nav-text">从服务器接收到请求到对应后台接收到请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#负载均衡"><span class="nav-number">4.3.1.</span> <span class="nav-text">负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后台的处理"><span class="nav-number">4.3.2.</span> <span class="nav-text">后台的处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后台和前台的http交互"><span class="nav-number">4.4.</span> <span class="nav-text">后台和前台的http交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#http报文结构"><span class="nav-number">4.4.1.</span> <span class="nav-text">http报文结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cookie以及优化"><span class="nav-number">4.4.2.</span> <span class="nav-text">cookie以及优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gzip压缩"><span class="nav-number">4.4.3.</span> <span class="nav-text">gzip压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#长连接与短连接"><span class="nav-number">4.4.4.</span> <span class="nav-text">长连接与短连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-2-0"><span class="nav-number">4.4.5.</span> <span class="nav-text">http 2.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#https"><span class="nav-number">4.4.6.</span> <span class="nav-text">https</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单独拎出来的缓存问题，http的缓存"><span class="nav-number">4.5.</span> <span class="nav-text">单独拎出来的缓存问题，http的缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强缓存与弱缓存"><span class="nav-number">4.5.1.</span> <span class="nav-text">强缓存与弱缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存头部简述"><span class="nav-number">4.5.2.</span> <span class="nav-text">缓存头部简述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#头部的区别"><span class="nav-number">4.5.3.</span> <span class="nav-text">头部的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析页面流程"><span class="nav-number">4.6.</span> <span class="nav-text">解析页面流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流程简述"><span class="nav-number">4.6.1.</span> <span class="nav-text">流程简述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTML解析，构建DOM"><span class="nav-number">4.6.2.</span> <span class="nav-text">HTML解析，构建DOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成CSS规则"><span class="nav-number">4.6.3.</span> <span class="nav-text">生成CSS规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构建渲染树"><span class="nav-number">4.6.4.</span> <span class="nav-text">构建渲染树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#渲染"><span class="nav-number">4.6.5.</span> <span class="nav-text">渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单层与复合层"><span class="nav-number">4.6.6.</span> <span class="nav-text">简单层与复合层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chrome中的调试"><span class="nav-number">4.6.7.</span> <span class="nav-text">Chrome中的调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源外链的下载"><span class="nav-number">4.6.8.</span> <span class="nav-text">资源外链的下载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loaded和domcontentloaded"><span class="nav-number">4.6.9.</span> <span class="nav-text">loaded和domcontentloaded</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS的可视化格式模型"><span class="nav-number">4.7.</span> <span class="nav-text">CSS的可视化格式模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包含块（Containing-Block）"><span class="nav-number">4.8.</span> <span class="nav-text">包含块（Containing Block）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#控制框（Controlling-Box）"><span class="nav-number">4.8.1.</span> <span class="nav-text">控制框（Controlling Box）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BFC（Block-Formatting-Context）"><span class="nav-number">4.8.2.</span> <span class="nav-text">BFC（Block Formatting Context）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IFC（Inline-Formatting-Context）"><span class="nav-number">4.8.3.</span> <span class="nav-text">IFC（Inline Formatting Context）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它"><span class="nav-number">4.8.4.</span> <span class="nav-text">其它</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS引擎解析过程"><span class="nav-number">4.9.</span> <span class="nav-text">JS引擎解析过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JS的解释阶段"><span class="nav-number">4.9.1.</span> <span class="nav-text">JS的解释阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JS的预处理阶段"><span class="nav-number">4.9.2.</span> <span class="nav-text">JS的预处理阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JS的执行阶段"><span class="nav-number">4.9.3.</span> <span class="nav-text">JS的执行阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回收机制"><span class="nav-number">4.9.4.</span> <span class="nav-text">回收机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它-1"><span class="nav-number">4.10.</span> <span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可以提到跨域"><span class="nav-number">4.10.1.</span> <span class="nav-text">可以提到跨域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可以提到web安全"><span class="nav-number">4.10.2.</span> <span class="nav-text">可以提到web安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更多"><span class="nav-number">4.10.3.</span> <span class="nav-text">更多</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写在最后的话"><span class="nav-number">6.</span> <span class="nav-text">写在最后的话</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他文章"><span class="nav-number">7.</span> <span class="nav-text">其他文章</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alvabill</span>

</div>


  









  <div class="footer-custom">Hosted by <a target="_blank" rel="external nofollow" href="https://pages.coding.me"><b>Coding Pages</b></a>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Symbols count total: </span>
    
    <span title="Symbols count total">80k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    
    <span title="Reading time total">2:14</span>
  
  </div>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  



  








  











  



  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  
    <script type="text/javascript">
      window.livereOptions = {
        refer: '基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/'
      };
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=6.4.1"></script>



  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! See more at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see here how to solve it: https://github.com/theme-next/hexo-leancloud-counter-security. \n But you also can use LeanCloud without security, by set \'security\' option to \'false\'.');
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "nkmgHuL14TznEIPB93o7Hgg3-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "nkmgHuL14TznEIPB93o7Hgg3-gzGzoHsz",
                'X-LC-Key': "fU3Xj9kGA23cwCvim1iQQIpe",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
  <script type="text/javascript">
  wpac_init = window.wpac_init || [];
  wpac_init.push({widget: 'Rating', id: 9384,
    el: 'wpac-rating',
    color: 'fc6423'
  });
  (function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = '//embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
  })();
  </script>


  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.4.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.4.1"></script>


  

  
  
  
    
  
  <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js"></script>
  <script type="text/javascript">
  
    bookmark.scrollToMark('auto', "#more");
  
  </script>


  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('Copied')
          else $(this).text('Copy failed')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script>


<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"width":80,"position":"left","vOffset":-150},"mobile":{"show":false}});</script></body>
</html>
