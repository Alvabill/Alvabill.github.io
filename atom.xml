<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alvabill</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://alvabill.ml/"/>
  <updated>2018-09-07T05:51:53.025Z</updated>
  <id>http://alvabill.ml/</id>
  
  <author>
    <name>Alvabill</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用正则匹配汇总</title>
    <link href="http://alvabill.ml/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E6%B1%87%E6%80%BB/"/>
    <id>http://alvabill.ml/常用正则匹配汇总/</id>
    <published>2018-05-04T15:44:40.000Z</published>
    <updated>2018-09-07T05:51:53.025Z</updated>
    
    <summary type="html">
    
      正则表达式常用的匹配汇总，欢迎评论区指正。不定时更新。
    
    </summary>
    
      <category term="干货汇总" scheme="http://alvabill.ml/categories/%E5%B9%B2%E8%B4%A7%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="regExp" scheme="http://alvabill.ml/tags/regExp/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript正则表达式进阶学习</title>
    <link href="http://alvabill.ml/JavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://alvabill.ml/JavaScript正则表达式进阶学习/</id>
    <published>2018-05-01T16:10:10.000Z</published>
    <updated>2018-09-07T05:51:52.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>作为一个有理想有追求的码农，能够风骚地使用正则表达式着实是一大快事。在别人还用着循规蹈矩的方式去写业务代码时，高级的正则却可以丢上一段简短的乱码优雅地解决问题，确实很风骚，不过也不能乱用，用前权衡一下可读性和可维护性吧。<br>众所周知，正则表达式主要用于匹配字符串中字符组合。在 JavaScript中，正则表达式也是对象。这些模式被用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp" title="此页面仍未被本地化, 期待您的翻译!" target="_blank" rel="noopener"><code>RegExp</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" title="exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。" target="_blank" rel="noopener"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" title="test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。" target="_blank" rel="noopener"><code>test</code></a> 方法, 以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String" title="此页面仍未被本地化, 期待您的翻译!" target="_blank" rel="noopener"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match" title="当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。" target="_blank" rel="noopener"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" title="replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。" target="_blank" rel="noopener"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search" title="search() 方法执行正则表达式和 String对象之间的一个搜索匹配。" target="_blank" rel="noopener"><code>search</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" title="split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。" target="_blank" rel="noopener"><code>split</code></a> 方法。<br>本文主要讨论正则的用法，包括常见和进阶用法，侧重高级用法，以及尽量通俗化地解释正则表达式中一些高深概念。</p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><p>一图胜过万千言语，思路非常清晰的思维导图整理，熟悉的可以跳过这部分<br><img src="https://sfault-image.b0.upaiyun.com/149/863/1498635521-593cdb9a5b29b" alt="https://segmentfault.com/u/sushi"></p><p>以上为一个系统的概论，对于本人，平时用到的主要有：</p><h3 id="匹配除换行符之外的任何单个字符"><a href="#匹配除换行符之外的任何单个字符" class="headerlink" title=". 匹配除换行符之外的任何单个字符"></a><code>.</code> 匹配除换行符之外的任何单个字符</h3><p>示例：<a href="http://www.regexlab.com/zh/workshop.htm?pat=a.%5Cd&amp;txt=aaa100" target="_blank" rel="noopener">表达式 <code>a.\d</code>，在匹配 “aaa100”</a> 时，匹配的结果是：成功；匹配到的内容是：”aa1”；匹配到的位置是：开始于1，结束于4。</p><p>用法：<code>/&lt;div&gt;(.*?)&lt;\/div&gt;/</code>可以匹配div标签内有换行的数据。另外如果想匹配包含换行的全部字符，可以使用<code>[\s\S]</code>代替<code>.</code>。</p><h3 id="s-匹配一个空白字符"><a href="#s-匹配一个空白字符" class="headerlink" title="\s 匹配一个空白字符"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space" target="_blank" rel="noopener"><code>\s</code></a> 匹配一个空白字符</h3><p>包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。</p><p>示例： <a href="http://www.regexlab.com/zh/workshop.htm?pat=%5CS%2b&amp;txt=abc%20123%20@#$%25" target="_blank" rel="noopener"><code>/\S+/</code> 匹配”abc 123 @#$%”</a>。</p><p>用法：[\s\S]表示匹配任意字符，\S是\s的反义。注意区分[\s\S]与.的区别。</p><h3 id="转义"><a href="#转义" class="headerlink" title="\ 转义"></a><code>\</code> 转义</h3><p>在表达式中有特殊意义，需要添加 “\” 才能匹配该字符本身的字符汇总表</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串的开始位置。要匹配 “^” 字符本身，请使用 “\^”</td></tr><tr><td>$</td><td>匹配输入字符串的结尾位置。要匹配 “$” 字符本身，请使用 “\$”</td></tr><tr><td>( )</td><td>标记一个子表达式的开始和结束位置。要匹配小括号，请使用 “(“ 和 “)“</td></tr><tr><td>[ ]</td><td>用来自定义能够匹配 ‘多种字符’ 的表达式。要匹配中括号，请使用 “[“ 和 “]“</td></tr><tr><td>{ }</td><td>修饰匹配次数的符号。要匹配大括号，请使用 “{“ 和 “}“</td></tr><tr><td>.</td><td>匹配除了换行符（\n）以外的任意一个字符。要匹配小数点本身，请使用 “.“</td></tr><tr><td>?</td><td>修饰匹配次数为 0 次或 1 次。要匹配 “?” 字符本身，请使用 “\?”</td></tr><tr><td>+</td><td>修饰匹配次数为至少 1 次。要匹配 “+” 字符本身，请使用 “+“</td></tr><tr><td>*</td><td>修饰匹配次数为 0 次或任意次。要匹配 “*“ 字符本身，请使用 “\*“</td></tr><tr><td>&#124;</td><td>左右两边表达式之间 “或” 关系。匹配 “&#124;” 本身，请使用 “\&#124;”</td></tr></tbody></table><p>常用：</p><blockquote><p><code>*</code> 匹配零个或更多个，即0~n<br><code>+</code> 匹配一个或更多个，即至少一个，1~n<br><code>^</code> 字符串开始<br><code>$</code> 字符串结束</p></blockquote><h3 id="用法"><a href="#用法" class="headerlink" title="[]用法"></a><code>[]</code>用法</h3><p> 使用方括号<code>[ ]</code>包含一系列字符，能够匹配其中任意一个字符。</p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td>[ab5@]</td><td>匹配 “a” 或 “b” 或 “5” 或 “@”</td></tr><tr><td>[^abc]</td><td>匹配 “a”,”b”,”c” 之外的任意一个字符</td></tr><tr><td>[f-k]</td><td>匹配 “f”~”k” 之间的任意一个字母,如果要包含<code>-</code>字符，可以给它加上转义<code>[\-]</code></td></tr><tr><td>[^A-F0-3]</td><td>匹配 “A”~“F”,”0”~“3” 之外的任意一个字符</td></tr></tbody></table><p>示例：<a href="http://www.regexlab.com/zh/workshop.htm?pat=%5Bbcd%5D%5Bbcd%5D&amp;txt=abc123" target="_blank" rel="noopener">表达式 “[bcd][bcd]“ 匹配 “abc123”</a> 时，匹配的结果是：成功；匹配到的内容是：”bc”；匹配到的位置是：开始于1，结束于3。</p><p>关于<code>[]</code>常见的错误用法是：<code>[ab|bc]</code>用来表示<code>ab</code>或<code>bc</code>，实际上，它得到的结果是<code>[abc|]</code>，即<code>a或b或c或|</code>这4个字符（单字符）的任意一个。这里可以改成<code>(ab|bc)</code>。<br>总结：<code>[]</code>里面的特殊符有五个：<code>[]-\^</code>，其他字符都是普通字符，包括<code>*.?</code>等。 </p><h3 id="次数修饰"><a href="#次数修饰" class="headerlink" title="次数修饰{}"></a>次数修饰<code>{}</code></h3><p>使用方法是：”次数修饰”放在”被修饰的表达式”后边。比如：”[bcd][bcd]” 可以写成 “[bcd]{2}”。</p><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td>{n}</td><td>表达式重复n次。 “\w{2}” 相当于 “\w\w”； “a{5}” 相当于 “aaaaa”</td></tr><tr><td>{m,n}</td><td>表达式至少重复m次，最多重复n次。 “ba{1,3}”可以匹配 “ba”或”baa”或”baaa”</td></tr><tr><td>{m,}</td><td>表达式至少重复m次。 “\w\d{2,}”可以匹配 “a12”,”_456”,”M12344”</td></tr><tr><td>?</td><td>匹配表达式0次或者1次，相当于 {0,1}</td></tr><tr><td>+</td><td>表达式至少出现1次，相当于 {1,}</td></tr><tr><td>*</td><td>表达式不出现或出现任意次，相当于 {0,}</td></tr></tbody></table><p>如果刚好需要匹配字符<code>{1}</code>，则正则需要给<code>{</code>进行转义，得到<code>\{1}</code>的正则。<br>如果<code>{}</code>中间不是数字，则<code>{}</code>本身不需要转义。</p><p><strong>PS：这里<code>?</code>也可以用于非贪婪模式。</strong></p><blockquote><p><strong>非贪婪模式</strong>：<br>在修饰匹配次数的特殊符号后再加上一个 “?” 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 “不匹配”。这种匹配原则叫作 “非贪婪” 模式，也叫作 “勉强” 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。</p></blockquote><h3 id="多个数据选一（常用于多字符）"><a href="#多个数据选一（常用于多字符）" class="headerlink" title="| 多个数据选一（常用于多字符）"></a><code>|</code> 多个数据选一（常用于多字符）</h3><p>对比<code>[]</code>里面的只能选一个字符功能，<code>|</code>常用于选取多个字符。<br>比如：http|ftp|svn 就需要用<code>|</code>分开，<code>|</code>的作用域是一直往后直到遇到括号，比如，对于源字符串<code>http|ftp|svn abc</code>匹配的结果是：’http’，’ftp’，’svn abc’。<br>想要匹配 <code>http abc</code>和<code>ftp abc</code>和<code>svn abc</code>就要使用括号把前边的协议括起来，如<code>(http|ftp|svn) abc</code> 可以得到预期的结果。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="()用法"></a><code>()</code>用法</h3><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-capturing-parentheses" target="_blank" rel="noopener"><code>(x)</code></a></td><td>匹配 ‘x’ 并且记住匹配项，就像下面的例子展示的那样。括号被称为 <em>捕获括号</em> 。模式<code>/(foo) (bar) \1 \2/</code>中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \1 和 \2 匹配字符串的后两个单词。注意 \1、\2、\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，’bar foo’.replace( /(…) (…)/, ‘$2 $1’ )。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-capturing-parentheses" target="_blank" rel="noopener"><code>(?:x)</code></a></td><td>匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-lookahead" target="_blank" rel="noopener"><code>x(?=y)</code></a></td><td>匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat&#124;Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-look-ahead" target="_blank" rel="noopener"><code>x(?!y)</code></a></td><td>匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。例如，/\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’</td></tr></tbody></table><p>模式<code>/(foo) (bar) \1 \2/</code>中的 ‘(foo)’ 和 ‘(bar)’都分别为子模式，匹配结果会得到一个<code>[1]</code>和<code>[2]</code>的子集数据（数组下标分别是1、2）。子模式也叫分组，利用子模式，可以得到想要取出来的数据。子模式1、2、3的计算方法为<strong>左括号</strong>的计数，从左到右，从1开始，比如上面的分组1得到的是<code>(foo)</code>里面的数据，分组2得到<code>(bar)</code>里面的数据。注意这里的非捕获组和断言的左括号都是不需要数的。</p><h3 id="常用正则匹配汇总"><a href="#常用正则匹配汇总" class="headerlink" title="常用正则匹配汇总"></a>常用正则匹配汇总</h3><p>常用的一下正则表达式的汇总——<a href="https://alvabill.ml/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E6%B1%87%E6%80%BB/">传送门</a>，欢迎修正补充。</p><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.regexlab.com/zh/regref.htm" target="_blank" rel="noopener">http://www.regexlab.com/zh/regref.htm</a></li><li><a href="http://www.zjmainstay.cn/my-regexp" target="_blank" rel="noopener">http://www.zjmainstay.cn/my-regexp</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></li></ol>]]></content>
    
    <summary type="html">
    
      JavaScript中的正则表达式在匹配字符串方面是极为强大的一个工具，在平时工作学习中也很常见，虽然我们的进阶学习可能平时不怎么用得上，不过加深对其的理解肯定可以为自己带来更大的方便，用起来也会更加得心应手。
    
    </summary>
    
      <category term="JavaScript" scheme="http://alvabill.ml/categories/JavaScript/"/>
    
    
      <category term="regExp" scheme="http://alvabill.ml/tags/regExp/"/>
    
      <category term="JavaScript" scheme="http://alvabill.ml/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端复习汇总</title>
    <link href="http://alvabill.ml/%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
    <id>http://alvabill.ml/前端复习汇总/</id>
    <published>2018-03-31T03:22:19.000Z</published>
    <updated>2018-09-07T05:51:53.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP-相关"><a href="#HTTP-相关" class="headerlink" title="HTTP 相关"></a>HTTP 相关</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http协议入门</a></li><li><a href="http://www.howardliu.cn/the-introduction-of-http-status-codes/" target="_blank" rel="noopener">HTTP状态码总结</a></li><li><a href="http://www.androidchina.net/6013.html" target="_blank" rel="noopener">服务器返回的14种常见HTTP状态码</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="noopener">TCP 协议简介</a></li><li><a href="http://www.cleey.com/blog/single/id/755.html" target="_blank" rel="noopener">TCP和UDP之间的区别</a></li><li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">通俗大白话来理解TCP协议的三次握手和四次分手</a></li><li><a href="https://www.oschina.net/news/77354/http-get-post-different" target="_blank" rel="noopener">HTTP 中 GET 与 POST 的区别</a></li><li><a href="https://segmentfault.com/a/1190000004556040#articleHeader0" target="_blank" rel="noopener">聊一聊 cookie</a></li><li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">从输入URL到页面加载发生了什么</a> （详细）</li><li><a href="https://segmentfault.com/a/1190000013662126#articleHeader16" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></li></ul><h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><ul><li><a href="https://segmentfault.com/a/1190000008377508?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly#articleHeader0" target="_blank" rel="noopener">浏览器缓存</a> （非常完整）</li><li><a href="https://segmentfault.com/a/1190000007326671" target="_blank" rel="noopener">前端跨域整理</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li><li><a href="https://juejin.im/post/59a3f2fe6fb9a0249471cbb4#heading-1" target="_blank" rel="noopener">浏览器兼容性问题解决方案 · 总结</a> （很完整，不够具体）</li><li><a href="http://blog.zhangruipeng.me/2015/10/22/Web-Connectivity/" target="_blank" rel="noopener">传统轮询、长轮询、服务器发送事件与WebSocket</a></li><li><a href="http://imweb.io/topic/58e3bfa845e5c13468f567d5" target="_blank" rel="noopener">浏览器进程？线程？傻傻分不清楚！</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li><a href="http://imweb.io/topic/56841c864c44bcc56092e3fa" target="_blank" rel="noopener">浏览器渲染原理</a></li><li><a href="http://web.jobbole.com/90961/" target="_blank" rel="noopener">浅析前端页面渲染机制</a></li><li><a href="https://zhuanlan.zhihu.com/p/25279069" target="_blank" rel="noopener">浏览器 渲染,绘制流程及性能优化</a></li><li><a href="http://caibaojian.com/css-reflow-repaint.html" target="_blank" rel="noopener">优化CSS重排重绘与浏览器性能</a></li></ul><h3 id="JavaScript-相关"><a href="#JavaScript-相关" class="headerlink" title="JavaScript 相关"></a>JavaScript 相关</h3><ul><li><a href="https://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">深入理解javascript原型和闭包</a>（很透彻）</li><li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">学习Javascript闭包（Closure）</a></li><li><a href="http://www.cnblogs.com/no-particular/archive/2013/01/31/2887293.html" target="_blank" rel="noopener">JavaScript执行环境 + 变量对象 + 作用域链 + 闭包</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise#%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">Promise实现原理</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">js内存管理和垃圾回收机制</a></li><li><a href="https://segmentfault.com/a/1190000004568177" target="_blank" rel="noopener">细谈JavaScript中的一些设计模式</a></li></ul><h3 id="CSS-相关"><a href="#CSS-相关" class="headerlink" title="CSS 相关"></a>CSS 相关</h3><ul><li><a href="https://www.jianshu.com/p/985d26b40199" target="_blank" rel="noopener">REM如何做自适应</a></li><li><a href="https://segmentfault.com/a/1190000003064142" target="_blank" rel="noopener">CSS选择器优先级与效率优化</a></li></ul><h3 id="框架工具-相关"><a href="#框架工具-相关" class="headerlink" title="框架工具 相关"></a>框架工具 相关</h3><ul><li><a href="https://www.zhihu.com/question/19653241" target="_blank" rel="noopener">使用 Node.js 的优势和劣势都有哪些？</a></li><li><a href="http://blog.guowenfh.com/2016/01/28/Bootstrap-03-Grid/" target="_blank" rel="noopener">BootStrap的栅格系统实现原理？</a></li><li><a href="https://juejin.im/post/5a0d5df1f265da43062a542f" target="_blank" rel="noopener">React，Angular 和 Vue 的比较</a> 2017</li><li><a href="http://imweb.io/topic/59324940b9b65af940bf58ae" target="_blank" rel="noopener">webpack原理与实战</a></li><li><a href="https://segmentfault.com/a/1190000007649656" target="_blank" rel="noopener">webpack 的几个重要概念</a></li><li><a href="https://segmentfault.com/a/1190000007649417" target="_blank" rel="noopener">webpack 代码拆分</a></li></ul><h3 id="实现相关"><a href="#实现相关" class="headerlink" title="实现相关"></a>实现相关</h3><ul><li><a href="https://juejin.im/post/5aa252ac518825558001d5de" target="_blank" rel="noopener">干货!各种常见布局实现+知名网站实例分析</a></li><li><a href="http://www.jb51.net/article/109496.htm" target="_blank" rel="noopener">JavaScript 实现 Tab 点击切换实例代码</a></li></ul><h3 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h3><ul><li><a href="https://juejin.im/post/57dcd394a22b9d00610c5ec8#heading-1" target="_blank" rel="noopener">十大经典排序算法总结（JavaScript描述）</a></li><li><a href="http://louiszhai.github.io/2016/12/23/sort/#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">JS中可能用得到的全部的排序算法</a> </li><li><a href="http://blog.csdn.net/xiao_spring/article/details/79208861" target="_blank" rel="noopener">javascript计算数组中某值的出现次数</a>  （关键–<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">reduce</a>）</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://github.com/wy-ei/notebook/issues/34" target="_blank" rel="noopener">性能优化</a></li><li><a href="https://segmentfault.com/a/1190000003646305" target="_blank" rel="noopener">前端性能优化指南</a> （具体详细）</li><li><a href="http://blog.csdn.net/stpeace/article/details/77840936" target="_blank" rel="noopener">微信网页版扫码登录是如何实现的</a></li><li><a href="https://www.jianshu.com/p/5e274f13d962" target="_blank" rel="noopener">【思考】前后端交互-一些关于接口设计</a></li><li><a href="https://juejin.im/entry/5a33290ef265da431876c832" target="_blank" rel="noopener">前后端分离，是为了彼此更好</a></li><li><a href="https://github.com/fouber/blog/issues/10" target="_blank" rel="noopener">前端工程——基础篇</a></li><li><a href="https://www.zhihu.com/question/20313385" target="_blank" rel="noopener">如何设计网站权限系统？</a></li><li><a href="https://www.cnblogs.com/vajoy/p/4176908.html" target="_blank" rel="noopener">浅谈WEB安全性（前端向）</a> （例子不错）</li></ul><h3 id="干货面经"><a href="#干货面经" class="headerlink" title="干货面经"></a>干货面经</h3><ul><li><a href="https://www.cnblogs.com/yugege/p/6526215.html" target="_blank" rel="noopener">2017CVTE</a></li><li><a href="https://segmentfault.com/a/1190000013654696?utm_source=index-hottest" target="_blank" rel="noopener">2018年腾讯前端一面总结（面向2019届学生）</a></li><li><a href="https://github.com/poetries/FE-Interview-Questions" target="_blank" rel="noopener">前端面试常考问题分类整理汇总</a></li><li><a href="https://www.nowcoder.com/discuss/64136?type=2&amp;order=0&amp;pos=17&amp;page=1" target="_blank" rel="noopener">迟到的前端面经</a> </li><li><a href="https://juejin.im/post/5abb22925188255c4c1050e0" target="_blank" rel="noopener">3月前端知识集锦</a></li><li><a href="https://juejin.im/post/5aae076d6fb9a028cc6100a9" target="_blank" rel="noopener">前端面试考点多？看这些文章就够了</a></li></ul>]]></content>
    
    <summary type="html">
    
      前端复习资料汇总（私人）
    
    </summary>
    
      <category term="前端杂烩" scheme="http://alvabill.ml/categories/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="JavaScript" scheme="http://alvabill.ml/tags/JavaScript/"/>
    
      <category term="面试" scheme="http://alvabill.ml/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="HTTP" scheme="http://alvabill.ml/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建</title>
    <link href="http://alvabill.ml/%E5%9F%BA%E4%BA%8E%E2%80%98%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E2%80%99%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%90%AD%E5%BB%BA/"/>
    <id>http://alvabill.ml/基于‘从输入URL到页面加载发生了什么’的相关知识体系搭建/</id>
    <published>2018-03-29T09:09:14.000Z</published>
    <updated>2018-09-07T05:51:53.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章灵感以及原型为“<a href="https://segmentfault.com/a/1190000013662126#articleHeader0" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a>”，本文主要基于该文章基础上进行修改补充以完善自身的知识体系，自用参考为主，侵删（^ - ^）</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>此部分的内容是站在个人视角分析的，并不是说就一定是正确答案</strong></p><p>首先明确，计算机方面的知识是可以无穷无尽的挖的，而本文的重点是梳理前端向的重点知识</p><p>对于前端向（这里可能没有提到node.js之类的，更多的是指客户端前端），这里将知识点按重要程度划分成以下几大类：</p><blockquote><p>核心知识，必须掌握的，也是最基础的，譬如浏览器模型，渲染原理，JS解析过程，JS运行机制等，作为骨架来承载知识体系<br>重点知识，往往每一块都是一个知识点，而且这些知识点都很重要，譬如http相关，web安全相关，跨域处理等<br>拓展知识，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特网协议栈，hybrid模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如hybrid开发时，懂原生开发是很重要的）</p></blockquote><h2 id="梳理主干流程"><a href="#梳理主干流程" class="headerlink" title="梳理主干流程"></a>梳理主干流程</h2><p>知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下主干流程：</p><ol><li>从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li><li>开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</li><li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li><li>后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</li><li>单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</li><li>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</li><li>CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</li><li>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</li><li>其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</li></ol><h2 id="细节内容填充"><a href="#细节内容填充" class="headerlink" title="细节内容填充"></a>细节内容填充</h2><h3 id="从浏览器接收url到开启网络请求线程"><a href="#从浏览器接收url到开启网络请求线程" class="headerlink" title="从浏览器接收url到开启网络请求线程"></a>从浏览器接收url到开启网络请求线程</h3><p>这一部分展开的内容是：浏览器进程/线程模型，JS的运行机制。</p><h4 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h4><p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）<br>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li></ul><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1522337517997.jpg" alt="Chrome浏览器的多进程"></p><h4 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h4><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：</p><ul><li>GUI线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器线程</li><li>网络请求线程</li></ul><p><em>相关文章：<a href="http://imweb.io/topic/58e3bfa845e5c13468f567d5" target="_blank" rel="noopener">浏览器进程与线程相关</a>、<a href="https://segmentfault.com/a/1190000012925872#articleHeader0" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></em></p><h4 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h4><p>输入URL后，会进行解析（URL的本质就是统一资源定位符）<br>URL一般包括几大部分：</p><ul><li><code>protocol</code>，协议头，譬如有http，ftp等</li><li><code>host</code>，主机域名或IP地址</li><li><code>port</code>，端口号</li><li><code>path</code>，目录路径</li><li><code>query</code>，即查询参数</li><li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</li></ul><h4 id="开辟网络请求线程"><a href="#开辟网络请求线程" class="headerlink" title="开辟网络请求线程"></a>开辟网络请求线程</h4><p>每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p><p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）</p><h3 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" class="headerlink" title="开启网络线程到发出一个完整的http请求"></a>开启网络线程到发出一个完整的http请求</h3><p>这一部分主要内容包括：<code>dns</code>查询，<code>tcp/ip</code>请求构建，<code>五层因特网协议栈</code>等等<br>仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）</p><h4 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h4><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p><p>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host<br>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP<br>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</p><p>而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化</p><p>这一块可以深入展开，具体请去网上搜索，这里就不占篇幅了（网上可以看到很详细的解答）</p><p><em>相关文章：<a href="http://imweb.io/topic/55e3ba46771670e207a16bc8" target="_blank" rel="noopener">DNS解析 – IMWeb</a>、<a href="http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/" target="_blank" rel="noopener">前端性能优化 - 资源预加载</a></em></p><h4 id="tcp-ip请求"><a href="#tcp-ip请求" class="headerlink" title="tcp/ip请求"></a>tcp/ip请求</h4><p>http的本质就是<code>tcp/ip</code>请求</p><p>需要了解3次握手规则建立连接以及断开连接时的四次挥手</p><p>tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输</p><p><strong>三次握手的步骤：（抽象派）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello，你是server么？</span><br><span class="line">服务端：hello，我是server，你是client么</span><br><span class="line">客户端：yes，我是client</span><br></pre></td></tr></table></figure><p>建立连接成功后，接下来就正式传输数据</p><p>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）</p><p><strong>四次挥手的步骤：（抽象派）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">被动方：收到通道关闭的信息</span><br><span class="line">被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure><p><em>相关文章：<a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">通俗大白话来理解TCP协议的三次握手和四次分手</a></em> </p><p><strong>tcp/ip的并发限制</strong></p><p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）</p><p>而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求</p><p>所以针对这个瓶颈，又出现了很多的资源优化方案</p><p><strong>get和post的区别</strong></p><p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。</p><p>get会产生一个tcp数据包，post两个</p><p>具体就是：</p><ul><li>get请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li><li>post请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>，</li></ul><p>浏览器再发送<code>data</code>，服务器响应200（返回数据）。</p><p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）</p><h4 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h4><p> <strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong></p><p>简括就是：</p><p><strong>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong></p><p>当然，服务端的接收就是反过来的步骤</p><p>五层因特网协议栈其实就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.应用层(dns,http) DNS解析成IP并发送http请求</span><br><span class="line"></span><br><span class="line">2.传输层(tcp,udp) 建立tcp连接（三次握手）</span><br><span class="line"></span><br><span class="line">3.网络层(IP,ARP) IP寻址</span><br><span class="line"></span><br><span class="line">4.数据链路层(PPP) 封装成帧</span><br><span class="line"></span><br><span class="line">5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure><p>当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。</p><p>OSI七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</span><br><span class="line"></span><br><span class="line">会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</span><br></pre></td></tr></table></figure><p><em>相关文章：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门 – 阮一峰</a>、<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI模型 – 维基百科</a></em></p><h3 id="从服务器接收到请求到对应后台接收到请求"><a href="#从服务器接收到请求到对应后台接收到请求" class="headerlink" title="从服务器接收到请求到对应后台接收到请求"></a>从服务器接收到请求到对应后台接收到请求</h3><p>服务端在接收到请求时，内部会进行很多的处理</p><p>这里由于不是专业的后端分析，所以只是简单的介绍下，不深入</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡</p><p>当然了，负载均衡不止这一种实现方式，这里不深入…</p><p>简单的说：</p><p><strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</strong></p><p><em>相关文章：<a href="https://my.oschina.net/liuyuantao/blog/812089" target="_blank" rel="noopener">六大Web负载均衡原理与实现</a></em></p><h4 id="后台的处理"><a href="#后台的处理" class="headerlink" title="后台的处理"></a>后台的处理</h4><p>一般后台都是部署到容器中的，所以一般为：</p><ul><li>先是容器接受到请求（如tomcat容器）</li><li>然后对应容器中的后台程序接收到请求（如java程序）</li><li>然后就是后台会有自己的统一处理，处理完后响应响应结果</li></ul><p>概括下：</p><ul><li>一般有的后端是有统一的验证的，如安全拦截，跨域验证</li><li>如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）</li><li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li><li>等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）</li><li>然后就是将这个包从后端发送到前端，完成交互</li></ul><h3 id="后台和前台的http交互"><a href="#后台和前台的http交互" class="headerlink" title="后台和前台的http交互"></a>后台和前台的http交互</h3><p>前后端交互时，http报文作为信息的载体</p><p>所以http是一块很重要的内容，这一部分重点介绍它</p><p><strong>建议阅读《htttp权威指南》</strong></p><h4 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h4><p>报文一般包括了：<code>通用头部</code>，<code>请求/响应头部</code>，<code>请求/响应体</code></p><p><strong>通用头部</strong></p><p>这也是开发人员见过的最多的信息，包括如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request Url: 请求的web服务器地址</span><br><span class="line"></span><br><span class="line">Request Method: 请求方式</span><br><span class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</span><br><span class="line"></span><br><span class="line">Status Code: 请求的返回状态码，如200代表成功</span><br><span class="line"></span><br><span class="line">Remote Address: 请求的远程服务器地址（会转为IP）</span><br></pre></td></tr></table></figure><p>譬如，在跨域拒绝时，可能是method为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）</p><p>其中，Method的话一般分为两批次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</span><br><span class="line">以及几种Additional Request Methods：PUT、DELETE、LINK、UNLINK</span><br><span class="line"></span><br><span class="line">HTTP1.1定义了八种请求方法：GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</span><br></pre></td></tr></table></figure><p><code>HTTP 1.0</code>定义参考：<a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1945</a></p><p><code>HTTP 1.1</code>定义参考：<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616</a></p><p>这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</span><br><span class="line">400——客户端请求有错（譬如可以是安全模块拦截）</span><br><span class="line">401——请求未经授权</span><br><span class="line">403——禁止访问（譬如可以是未登录时禁止）</span><br><span class="line">404——资源未找到</span><br><span class="line">500——服务器内部错误</span><br><span class="line">503——服务不可用</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再列举下大致不同范围状态的意义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx——指示信息，表示请求已接收，继续处理</span><br><span class="line">2xx——成功，表示请求已被成功接收、理解、接受</span><br><span class="line">3xx——重定向，要完成请求必须进行更进一步的操作</span><br><span class="line">4xx——客户端错误，请求有语法错误或请求无法实现</span><br><span class="line">5xx——服务器端错误，服务器未能实现合法的请求</span><br></pre></td></tr></table></figure><p><em>相关文章：<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门 – 阮一峰</a>、<a href="http://www.howardliu.cn/the-introduction-of-http-status-codes/" target="_blank" rel="noopener">HTTP状态码总结</a></em></p><p><strong>请求/响应头部</strong></p><p>请求和响应头部也是分析时常用到的</p><p>常用的请求头部（部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Accept: 接收类型，表示浏览器支持的MIME类型</span><br><span class="line">（对标服务端返回的Content-Type）</span><br><span class="line">Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收</span><br><span class="line">Content-Type：客户端发送出去实体内容的类型</span><br><span class="line">Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache</span><br><span class="line">If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中</span><br><span class="line">Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</span><br><span class="line">Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</span><br><span class="line">If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</span><br><span class="line">Cookie: 有cookie并且同域访问时会自动带上</span><br><span class="line">Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive</span><br><span class="line">Host：请求的服务器URL</span><br><span class="line">Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</span><br><span class="line">Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</span><br><span class="line">User-Agent：用户客户端的一些必要信息，如UA头部等</span><br></pre></td></tr></table></figure><p>常用的响应头部（部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: 服务器端允许的请求Headers</span><br><span class="line">Access-Control-Allow-Methods: 服务器端允许的请求方法</span><br><span class="line">Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）</span><br><span class="line">Content-Type：服务端返回的实体内容的类型</span><br><span class="line">Date：数据从服务器发送的时间</span><br><span class="line">Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line">Last-Modified：请求资源的最后修改时间</span><br><span class="line">Expires：应该在什么时候认为文档已经过期,从而不再缓存它</span><br><span class="line">Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</span><br><span class="line">ETag：请求变量的实体标签的当前值</span><br><span class="line">Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</span><br><span class="line">Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</span><br><span class="line">Server：服务器的一些相关信息</span><br></pre></td></tr></table></figure><p>一般来说，请求头部和响应头部是匹配分析的。</p><p>譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错</p><p>譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误</p><p>譬如，在使用缓存时，请求头部的<code>If-Modified-Since</code>、<code>If-None-Match</code>分别和响应头部的<code>Last-Modified</code>、<code>ETag</code>对应</p><p>还有很多的分析方法，这里不一一赘述</p><p><strong>请求/响应实体</strong></p><p>http请求时，除了头部，还有消息实体，一般来说</p><p>请求实体中会将一些需要的参数都放入进入（用于post请求）。</p><p>譬如实体中可以放参数的序列化形式（<code>a=1&amp;b=2</code>这种），或者直接放表单对象（<code>Form Data</code>对象，上传时可以夹杂参数以及文件），等等</p><p>而一般响应实体中，就是放服务端需要传给客户端的内容</p><p>一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。</p><p><strong>CRLF</strong></p><p>CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在</p><p>请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔</p><p>一般来说（分隔符类别）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRLF-&gt;Windows-style</span><br><span class="line">LF-&gt;Unix Style</span><br><span class="line">CR-&gt;Mac Style</span><br></pre></td></tr></table></figure></p><h4 id="cookie以及优化"><a href="#cookie以及优化" class="headerlink" title="cookie以及优化"></a>cookie以及优化</h4><p>cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。</p><p>场景如下（简述）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在登陆页面，用户登陆了</span><br><span class="line"></span><br><span class="line">此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）</span><br><span class="line"></span><br><span class="line">然后会有一个sessionid（相当于是服务端的这个session对应的key）</span><br><span class="line"></span><br><span class="line">然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx</span><br><span class="line"></span><br><span class="line">然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br></pre></td></tr></table></figure><p>上述就是cookie的常用场景简述（当然了，实际情况下得考虑更多因素）</p><p>一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置<code>httponly</code>（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）</p><p>另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。</p><p>譬如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line"></span><br><span class="line">然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源）</span><br><span class="line"></span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line"></span><br><span class="line">也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line"></span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure><p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p><ul><li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li><li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的cookie的，所以就避免了浪费</li></ul><p>说到了多域名拆分，这里再提一个问题，那就是：</p><ul><li>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）</li><li>此时就需要用到一种优化方案：<code>dns-prefetch</code>（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</li></ul><h4 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h4><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持），<br>而且gzip压缩效率很好（高达70%左右）</p><p>然后gzip一般是由<code>apache</code>、<code>tomcat</code>等web服务器开启</p><p>当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）</p><p>所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的，非常方便。</p><h4 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h4><p>首先看<code>tcp/ip</code>层面的定义：</p><ul><li>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li><li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li></ul><p>然后在http层面：</p><ul><li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li><li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li></ul><p>注意： <strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</strong></p><h4 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h4><p>http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）</p><p>然后简述下http2.0与http1.1的显著不同点：</p><ul><li>http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li><li>http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li></ul><p>所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）</p><p>然后简述下http2.0的一些特性：</p><ul><li>多路复用（即一个tcp/ip连接可以请求多个资源）</li><li>首部压缩（http头部压缩，减少体积）</li><li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li><li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li><li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li></ul><h4 id="https"><a href="#https" class="headerlink" title="https"></a>https</h4><p>https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。</p><p>简单来看，https与http的区别就是： <strong>在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong></p><p>一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）</p><p>一般来说，主要关注的就是SSL/TLS的握手流程，如下（简述）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 </span><br><span class="line"></span><br><span class="line">2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器</span><br><span class="line">（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</span><br><span class="line"></span><br><span class="line">3. 浏览器收到服务端的证书后</span><br><span class="line"></span><br><span class="line">    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</span><br><span class="line"></span><br><span class="line">    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。</span><br><span class="line"></span><br><span class="line">    - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`</span><br><span class="line"></span><br><span class="line">    - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。 </span><br><span class="line"></span><br><span class="line">4. 服务端收到浏览器的回复</span><br><span class="line"></span><br><span class="line">    - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`</span><br><span class="line"></span><br><span class="line">    - 和浏览器相同规则生成`session key`</span><br><span class="line"></span><br><span class="line">    - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</span><br><span class="line"></span><br><span class="line">    - 使用`session key`加密一段握手消息，发送给浏览器</span><br><span class="line"></span><br><span class="line">5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，</span><br></pre></td></tr></table></figure><p><strong>之后所有的https通信数据将由之前浏览器生成的<code>session key</code>并利用对称加密算法进行加密</strong>。</p><h3 id="单独拎出来的缓存问题，http的缓存"><a href="#单独拎出来的缓存问题，http的缓存" class="headerlink" title="单独拎出来的缓存问题，http的缓存"></a>单独拎出来的缓存问题，http的缓存</h3><p>前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的</p><h4 id="强缓存与弱缓存"><a href="#强缓存与弱缓存" class="headerlink" title="强缓存与弱缓存"></a>强缓存与弱缓存</h4><p>缓存可以简单的划分成两种类型：<code>强缓存</code>（<code>200 from cache</code>）与<code>协商缓存</code>（<code>304</code>）</p><p>区别简述如下：</p><ul><li>强缓存（<code>200 from cache</code>）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求</li><li>协商缓存（<code>304</code>）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li></ul><p>对于协商缓存，使用<code>Ctrl + F5</code>强制刷新可以使得缓存无效</p><p>但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）</p><h4 id="缓存头部简述"><a href="#缓存头部简述" class="headerlink" title="缓存头部简述"></a>缓存头部简述</h4><p>上述提到了强缓存和协商缓存，那它们是怎么区分的呢？</p><p>答案是通过不同的http头部控制</p><p>先看下这几个头部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires</span><br></pre></td></tr></table></figure><p>这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。</p><p>属于强缓存控制的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）Cache-Control/Max-Age</span><br><span class="line">（http1.0）Pragma/Expires</span><br></pre></td></tr></table></figure><p>注意：<strong><code>Max-Age</code>不是一个头部，它是<code>Cache-Control</code>头部的值</strong></p><p>属于协商缓存控制的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）If-None-Match/E-tag</span><br><span class="line">（http1.0）If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure><p>可以看到，上述有提到<code>http1.1</code>和<code>http1.0</code>，这些不同的头部是属于不同http时期的</p><p>再提一点，其实HTML页面中也有一个meta标签可以控制缓存方案-<code>Pragma</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure><p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐</p><h4 id="头部的区别"><a href="#头部的区别" class="headerlink" title="头部的区别"></a>头部的区别</h4><p>首先明确，http的发展是从http1.0到http1.1</p><p>而在http1.1中，出了一些新内容，弥补了http1.0的不足。</p><p><strong>http1.0中的缓存控制：</strong></p><ul><li><code>Pragma</code>：严格来说，它不属于专门的缓存控制头部，但是它设置<code>no-cache</code>时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）</li><li><code>Expires</code>：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如<code>Expires：Fri, 30 Oct 1998 14:19:41</code></li><li><code>If-Modified-Since/Last-Modified</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-Modified-Since</code>，而服务端的是<code>Last-Modified</code>，它的作用是，在发起请求时，如果<code>If-Modified-Since</code>和<code>Last-Modified</code>匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。<code>Last-Modified</code>，顾名思义，指的是文件最后的修改时间，而且只能精确到<code>1s</code>以内</li></ul><p><strong>http1.1中的缓存控制：</strong></p><ul><li><code>Cache-Control</code>：缓存控制头部，有no-cache、max-age等多种取值</li><li><code>Max-Age</code>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如<code>Cache-Control: max-age=3600</code>，而且它值得是绝对时间，由浏览器自己计算</li><li><code>If-None-Match/E-tag</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-None-Match</code>，而服务端的是<code>E-tag</code>，同样，发出请求后，如果<code>If-None-Match</code>和<code>E-tag</code>匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于<code>FileEtag INode Mtime Size</code>生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li></ul><p><strong>Max-Age相比Expires？</strong></p><p><code>Expires</code>使用的是服务器端的时间</p><p>但是有时候会有这样一种情况-客户端时间和服务端不同步</p><p>那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期</p><p>所以一般http1.1后不推荐使用<code>Expires</code></p><p>而<code>Max-Age</code>使用的是客户端本地时间的计算，因此不会有这个问题</p><p>因此推荐使用<code>Max-Age</code>。</p><p>注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。</p><p><strong>E-tag相比Last-Modified？</strong></p><p><code>Last-Modified</code>：</p><ul><li>表明服务端的文件最后何时改变的</li><li>它有一个缺陷就是只能精确到1s，</li><li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li></ul><p>而<code>E-tag</code>：</p><ul><li>是一种指纹机制，代表文件相关指纹</li><li>只有文件变才会变，也只要文件变就会变，</li><li>也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</li></ul><p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code></p><p>各大缓存头部的整体关系如下图<br><img src="https://sfault-image.b0.upaiyun.com/107/814/107814026-5aa5cafca80bf_articlex" alt=""></p><p><em>相关文章：<a href="https://segmentfault.com/a/1190000008377508?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly#articleHeader0" target="_blank" rel="noopener">浏览器缓存</a></em></p><h3 id="解析页面流程"><a href="#解析页面流程" class="headerlink" title="解析页面流程"></a>解析页面流程</h3><h4 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h4><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 解析HTML，构建DOM树</span><br><span class="line"></span><br><span class="line">2. 解析CSS，生成CSS规则树</span><br><span class="line"></span><br><span class="line">3. 合并DOM树和CSS规则，生成render树</span><br><span class="line"></span><br><span class="line">4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算</span><br><span class="line"></span><br><span class="line">5. 绘制render树（paint），绘制页面像素信息</span><br><span class="line"></span><br><span class="line">6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</span><br></pre></td></tr></table></figure><p><img src="https://sfault-image.b0.upaiyun.com/137/309/1373095523-5a658fc12f1fd_articlex" alt="渲染步骤"></p><h4 id="HTML解析，构建DOM"><a href="#HTML解析，构建DOM" class="headerlink" title="HTML解析，构建DOM"></a>HTML解析，构建DOM</h4><p>整个渲染步骤中，HTML解析是第一步。</p><p>简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong></p><p>但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。</p><p>解析HTML到构建出DOM当然过程可以简述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure><p>譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critical Path&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>浏览器的处理如下：</p><p><img src="https://sfault-image.b0.upaiyun.com/236/309/2363096142-5aa5cafc74a50_articlex" alt=""></p><p>列举其中的一些重点过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</span><br><span class="line"></span><br><span class="line">2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</span><br><span class="line"></span><br><span class="line">3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</span><br><span class="line"></span><br><span class="line">4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</span><br><span class="line">例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象</span><br></pre></td></tr></table></figure><p>最后的DOM树如下：</p><p><img src="https://sfault-image.b0.upaiyun.com/226/254/2262547194-5aa5cafc2e219_articlex" alt=""></p><h4 id="生成CSS规则"><a href="#生成CSS规则" class="headerlink" title="生成CSS规则"></a>生成CSS规则</h4><p>同理，CSS规则树的生成也是类似。简述为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure><p>譬如<code>style.css</code>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure><p>那么最终的CSSOM树就是：</p><p><img src="https://sfault-image.b0.upaiyun.com/324/599/3245996893-5aa5cafbecf07_articlex" alt=""></p><h4 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h4><p>当DOM树和CSSOM都有了后，就要开始构建渲染树了</p><p>一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应</p><p>因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者<code>display: none</code>等</p><p>整体来说可以看图：</p><p><img src="https://sfault-image.b0.upaiyun.com/316/642/316642185-5aa5cafc36e11_articlex" alt=""></p><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>有了render树，接下来就是开始渲染，基本流程如下：</p><p><img src="https://sfault-image.b0.upaiyun.com/588/361/588361506-5aa5cafbe158d_articlex" alt=""></p><p>图中重要的四个步骤就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 计算CSS样式</span><br><span class="line"></span><br><span class="line">2. 构建渲染树</span><br><span class="line"></span><br><span class="line">3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性</span><br><span class="line"></span><br><span class="line">4. 绘制，将图像绘制出来</span><br></pre></td></tr></table></figure><p>然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）</p><p>这里Layout和Repaint的概念是有区别的：</p><ul><li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li><li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li></ul><p>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，<br>所以优化方案中一般都包括，尽量避免回流。</p><p><strong>什么会引起回流？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.页面渲染初始化</span><br><span class="line"></span><br><span class="line">2.DOM结构改变，比如删除了某个节点</span><br><span class="line"></span><br><span class="line">3.render树变化，比如减少了padding</span><br><span class="line"></span><br><span class="line">4.窗口resize</span><br><span class="line"></span><br><span class="line">5.最复杂的一种：获取某些属性，引发回流，</span><br><span class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，</span><br><span class="line">但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （1）offset(Top/Left/Width/Height)</span><br><span class="line">     (2) scroll(Top/Left/Width/Height)</span><br><span class="line">     (3) cilent(Top/Left/Width/Height)</span><br><span class="line">     (4) width,height</span><br><span class="line">     (5) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure><p>回流一定伴随着重绘，重绘却可以单独出现</p><p>所以一般会有一些优化方案，如：</p><ul><li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li><li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li><li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li></ul><p><strong>注意：改变字体大小会引发回流</strong></p><p>再来看一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line"></span><br><span class="line">s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line">s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line">s.color = &quot;blue&quot;; // 再一次重绘</span><br><span class="line">s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘</span><br><span class="line">s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line">// 添加node，再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&apos;abc!&apos;));</span><br></pre></td></tr></table></figure><h4 id="简单层与复合层"><a href="#简单层与复合层" class="headerlink" title="简单层与复合层"></a>简单层与复合层</h4><p>上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。</p><p>这里不展开，进简单介绍下：</p><ul><li>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的</li><li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li><li>复合图层之间的绘制互不干扰，由GPU直接控制</li><li>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li></ul><p>更多参考：</p><p><a href="https://segmentfault.com/a/1190000012925872#articleHeader16" target="_blank" rel="noopener">普通图层和复合图层</a></p><h4 id="Chrome中的调试"><a href="#Chrome中的调试" class="headerlink" title="Chrome中的调试"></a>Chrome中的调试</h4><p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：</p><p><img src="https://sfault-image.b0.upaiyun.com/138/671/1386713703-5aa5cafbad312_articlex" alt=""><br><img src="https://sfault-image.b0.upaiyun.com/169/903/1699039536-5aa5cafb9b136_articlex" alt=""></p><h4 id="资源外链的下载"><a href="#资源外链的下载" class="headerlink" title="资源外链的下载"></a>资源外链的下载</h4><p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了</p><p>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p><ul><li>CSS样式资源</li><li>JS脚本资源</li><li>img图片类资源</li></ul><p><strong>遇到外链时的处理</strong></p><p>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</p><p><strong>遇到CSS样式资源</strong></p><p>CSS资源的处理有几个特点：</p><ul><li>CSS下载时异步，不会阻塞浏览器构建DOM树</li><li>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li><li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li></ul><p><strong>遇到JS脚本资源</strong></p><p>JS脚本资源的处理有几个特点：</p><ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li><li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li><li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul><p><img src="https://sfault-image.b0.upaiyun.com/215/179/2151798436-59da4801c6772" alt="JS脚本解析"></p><p>注意，defer和async是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong></p><p>简单的说（不展开）：</p><ul><li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li><li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了<code>body</code>后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><p><strong>遇到img图片类资源</strong></p><p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p><h4 id="loaded和domcontentloaded"><a href="#loaded和domcontentloaded" class="headerlink" title="loaded和domcontentloaded"></a>loaded和domcontentloaded</h4><p>简单的对比：</p><ul><li>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li><li>load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li></ul><p><em>相关文章：<a href="https://segmentfault.com/a/1190000010298038" target="_blank" rel="noopener">浏览器渲染页面过程与页面优化</a>（更详细，而且参考链接很重要）</em></p><h3 id="CSS的可视化格式模型"><a href="#CSS的可视化格式模型" class="headerlink" title="CSS的可视化格式模型"></a>CSS的可视化格式模型</h3><p><strong>这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源</strong></p><p>前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： <strong>CSS的可视化格式模型</strong></p><p>先了解：</p><ul><li>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li><li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局</li><li>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</li></ul><p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong></p><p>关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">包含块（Containing Block）</span><br><span class="line">控制框（Controlling Box）</span><br><span class="line">BFC（Block Formatting Context）</span><br><span class="line">IFC（Inline Formatting Context）</span><br><span class="line">定位体系</span><br><span class="line">浮动</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的</p><h3 id="包含块（Containing-Block）"><a href="#包含块（Containing-Block）" class="headerlink" title="包含块（Containing Block）"></a>包含块（Containing Block）</h3><p>一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。</p><p>元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系</p><p>譬如：</p><ul><li>根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li><li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li><li>fixed的包含块是当前可视窗口</li><li><p>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建</p><ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li></ul></li></ul><h4 id="控制框（Controlling-Box）"><a href="#控制框（Controlling-Box）" class="headerlink" title="控制框（Controlling Box）"></a>控制框（Controlling Box）</h4><p>块级元素和块框以及行内元素和行框的相关概念</p><p><strong>块框:</strong></p><ul><li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li><li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li></ul><p>关于<strong>匿名块框</strong>的生成，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">Some text</span><br><span class="line">&lt;P&gt;More text</span><br><span class="line">&lt;/DIV&gt;</span><br></pre></td></tr></table></figure><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是<code>IFC</code>中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）</p><p>换句话说:</p><p><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong></p><p><strong>行内框：</strong></p><ul><li>一个行内元素生成一个行内框</li><li>行内元素能排在一行，允许左右有其它元素</li></ul><p>关于<strong>匿名行内框</strong>的生成，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;P&gt;Some &lt;EM&gt;emphasized&lt;/EM&gt; text&lt;/P&gt;</span><br></pre></td></tr></table></figure><p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some</code>，<code>text</code>，此时会专门为这些文本生成匿名行内框</p><p><strong>display属性的影响</strong></p><p><code>display</code>的几个属性也可以影响不同框的生成：</p><ul><li><code>block</code>，元素生成一个块框</li><li><code>inline</code>，元素产生一个或多个的行内框</li><li><code>inline-block</code>，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）</li><li><code>none</code>，不生成框，不再格式化结构中，当然了，另一个<code>visibility: hidden</code>则会产生一个不可见的框</li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列</li></ul><h4 id="BFC（Block-Formatting-Context）"><a href="#BFC（Block-Formatting-Context）" class="headerlink" title="BFC（Block Formatting Context）"></a>BFC（Block Formatting Context）</h4><p>FC（格式上下文）？</p><p>FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FC像是一个大箱子，里面装有很多元素</span><br><span class="line"></span><br><span class="line">箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）</span><br><span class="line"></span><br><span class="line">内部的规则可以是：如何定位，宽高计算，margin折叠等等</span><br></pre></td></tr></table></figure><p>不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC</p><p><strong>注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则</strong></p><p><strong>BFC规则：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在块格式化上下文中</span><br><span class="line"></span><br><span class="line">每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）</span><br><span class="line"></span><br><span class="line">即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）</span><br><span class="line"></span><br><span class="line">除非这个元素也创建了一个新的BFC</span><br></pre></td></tr></table></figure><p>总结几点BFC特点：</p><ol><li>内部<code>box</code>在垂直方向，一个接一个的放置</li><li>box的垂直方向由<code>margin</code>决定，属于同一个BFC的两个box间的margin会重叠</li><li>BFC区域不会与<code>float box</code>重叠（可用于排版)</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li><li>计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）</li></ol><p>如何触发BFC？</p><ol><li>根元素</li><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>display</code>为<code>inline-block</code>, <code>flex</code>, <code>inline-flex</code>，<code>table</code>，<code>table-cell</code>，<code>table-caption</code></li><li><code>overflow</code>不为<code>visible</code></li></ol><p>这里提下，<code>display: table</code>，它本身不产生BFC，但是它会产生匿名框（包含<code>display: table-cell</code>的框），而这个匿名框产生BFC</p><p>更多请自行网上搜索</p><h4 id="IFC（Inline-Formatting-Context）"><a href="#IFC（Inline-Formatting-Context）" class="headerlink" title="IFC（Inline Formatting Context）"></a>IFC（Inline Formatting Context）</h4><p>IFC即行内框产生的格式上下文</p><p><strong>IFC规则</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在行内格式化上下文中</span><br><span class="line"></span><br><span class="line">框一个接一个地水平排列，起点是包含块的顶部。</span><br><span class="line"></span><br><span class="line">水平方向上的 margin，border 和 padding 在框之间得到保留</span><br><span class="line"></span><br><span class="line">框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</span><br></pre></td></tr></table></figure><p><strong>行框</strong></p><p><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong></p><p>行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定</p><p>行框的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）</span><br><span class="line"></span><br><span class="line">行框在堆叠时没有垂直方向上的分割且永不重叠</span><br><span class="line"></span><br><span class="line">行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）</span><br><span class="line"></span><br><span class="line">行框的左边接触到其包含块的左边，右边接触到其包含块的右边。</span><br></pre></td></tr></table></figure><p><strong>结合补充下IFC规则：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">浮动元素可能会处于包含块边缘和行框边缘之间</span><br><span class="line"></span><br><span class="line">尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化</span><br><span class="line"></span><br><span class="line">同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）</span><br><span class="line"></span><br><span class="line">当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性</span><br><span class="line"></span><br><span class="line">空的行内框应该被忽略</span><br><span class="line"></span><br><span class="line">即不包含文本，保留空白符，margin/padding/border非0的行内元素，</span><br><span class="line">以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，</span><br><span class="line">并且不是以换行结束的行框，</span><br><span class="line">必须被当作零高度行框对待</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>行内元素总是会应用IFC渲染规则</li><li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li><li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li><li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li><li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li></ul><p>相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件）</p><p>但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>当然还有有一些其它内容：</p><ul><li>譬如常规流，浮动，绝对定位等区别</li><li>譬如浮动元素不包含在常规流中</li><li>譬如相对定位，绝对定位，<code>Fixed</code>定位等区别</li><li>譬如<code>z-index</code>的分层显示机制等</li></ul><p>这里不一一展开，更多请参考：</p><p><a href="http://bbs.csdn.net/topics/340204423" target="_blank" rel="noopener">http://bbs.csdn.net/topics/340204423</a></p><h3 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h3><p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）</p><h4 id="JS的解释阶段"><a href="#JS的解释阶段" class="headerlink" title="JS的解释阶段"></a>JS的解释阶段</h4><p>首先得明确： <strong>JS是解释型语音，所以它无需提前编译，而是由解释器实时运行</strong></p><p>引擎对JS的处理过程可以简述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</span><br><span class="line"></span><br><span class="line">2. 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</span><br><span class="line"></span><br><span class="line">3. 使用翻译器（translator），将代码转为字节码（bytecode）</span><br><span class="line"></span><br><span class="line">4. 使用字节码解释器（bytecode interpreter），将字节码转为机器码</span><br></pre></td></tr></table></figure><p>最终计算机执行的就是机器码。</p><p>为了提高运行速度，现代浏览器一般采用即时编译（<code>JIT-Just In Time compiler</code>）</p><p>即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（<code>inline cache</code>）</p><p>这样整个程序的运行速度能得到显著提升。</p><p>而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）</p><p>总结起来可以认为是： <strong>核心的<code>JIT</code>编译器将源码编译成机器码运行</strong></p><h4 id="JS的预处理阶段"><a href="#JS的预处理阶段" class="headerlink" title="JS的预处理阶段"></a>JS的预处理阶段</h4><p>上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段<br>（譬如变量提升，分号补全等）</p><p>预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分：</p><p><strong>分号补全</strong></p><p>JS执行是需要分号的，但为什么以下语句却可以正常运行呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;a&apos;)</span><br><span class="line">console.log(&apos;b&apos;)</span><br></pre></td></tr></table></figure><p>原因就是JS解释器有一个<a href="http://inimino.org/~inimino/blog/javascript_semicolons" target="_blank" rel="noopener">Semicolon Insertion</a>规则，它会按照一定规则，在适当的位置补充分号</p><p>譬如列举几条自动加分号的规则：</p><ul><li>当有换行符（包括含有换行符的多行注释），并且下一个<code>token</code>没法跟前面的语法匹配时，会自动补分号。</li><li>当有<code>}</code>时，如果缺少分号，会补分号。</li><li>程序源代码结束时，如果缺少分号，会补分号。</li></ul><p>于是，上述的代码就变成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;a&apos;);</span><br><span class="line">console.log(&apos;b&apos;);</span><br></pre></td></tr></table></figure><p>所以可以正常运行</p><p>当然了，这里有一个经典的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return</span><br><span class="line">    &#123;</span><br><span class="line">        a: &apos;a&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分号补全机制，所以它变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return;</span><br><span class="line">    &#123;</span><br><span class="line">        a: &apos;a&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以运行后是<code>undefined</code></p><p><strong>变量提升</strong></p><p>一般包括函数提升和变量提升</p><p>譬如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">b();</span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br></pre></td></tr></table></figure><p>经过变量提升后，就变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br><span class="line">a = 1;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>这里没有展开，其实展开也可以牵涉到很多内容的</p><p>譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及es6中let有关的临时死区等</p><h4 id="JS的执行阶段"><a href="#JS的执行阶段" class="headerlink" title="JS的执行阶段"></a>JS的执行阶段</h4><p>此阶段的内容中的图片来源：<a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html" target="_blank" rel="noopener">深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇）</a></p><p>解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><ul><li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li><li>VO（变量对象）和AO（活动对象）</li><li>作用域链</li><li>this机制等</li></ul><p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性</p><p><strong>执行上下文简单解释</strong></p><ul><li>JS有<code>执行上下文</code>）</li><li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入执行栈栈顶（不可被弹出）</li><li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部</li><li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。</li><li>这样依次执行（最终都会回到全局执行上下文）</li></ul><p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收</p><p><img src="https://sfault-image.b0.upaiyun.com/620/422/620422871-570d14feaf681_articlex" alt=""></p><p>然后执行上下文与VO，作用域链，this的关系是：</p><p>每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object，VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul><p><img src="https://sfault-image.b0.upaiyun.com/181/531/1815319493-570948eed9b27_articlex" alt=""></p><p><strong>VO与AO</strong></p><p>VO是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong></p><p>AO（<code>activation object</code>)，当函数被调用者激活，AO就被创建了</p><p>可以理解为：</p><ul><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>总的来说，VO中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）</p><p><strong>作用域链</strong></p><p>它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。</p><p>譬如流程简述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在函数上下文中，查找一个变量foo</span><br><span class="line"></span><br><span class="line">如果函数的VO中找到了，就直接使用</span><br><span class="line"></span><br><span class="line">否则去它的父级作用域链中（__parent__）找</span><br><span class="line"></span><br><span class="line">如果父级中没找到，继续往上找</span><br><span class="line"></span><br><span class="line">直到全局上下文中也没找到就报错</span><br></pre></td></tr></table></figure><p><img src="https://sfault-image.b0.upaiyun.com/171/264/1712643983-570d14ffae847_articlex" alt=""></p><p><strong>this指针</strong></p><p>这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分</p><p>注意：<strong>this是执行上下文环境的一个属性，而不是某个变量对象的属性</strong></p><p>因此:</p><ul><li>this是没有一个类似搜寻变量的过程</li><li>当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li>this的值只取决中进入上下文时的情况</li></ul><p>所以经典的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var baz = 200;</span><br><span class="line">var bar = &#123;</span><br><span class="line">    baz: 100,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        console.log(this.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var foo = bar.foo;</span><br><span class="line"></span><br><span class="line">// 进入环境：global</span><br><span class="line">foo(); // 200，严格模式中会报错，Cannot read property &apos;baz&apos; of undefined</span><br><span class="line"></span><br><span class="line">// 进入环境：global bar</span><br><span class="line">bar.foo(); // 100</span><br></pre></td></tr></table></figure><p>就要明白了上面this的介绍，上述例子很好理解</p><p>更多参考：</p><p><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html" target="_blank" rel="noopener">深入理解JavaScript系列（13）：This? Yes,this!</a></p><h4 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h4><p>JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。</p><p>一般来说，垃圾处理器有自己的回收策略。</p><p>譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）</p><p>常用的两种垃圾回收规则是：</p><ul><li>标记清除</li><li>引用计数</li></ul><p>Javascript引擎基础GC方案是（<code>simple GC</code>）：<code>mark and sweep</code>（标记清除），简单解释如下：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><p>譬如：（出自javascript高程）</p><blockquote><p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。</p><p>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</p><p>而当变量离开环境时，则将其标记为“离开环境”。</p><p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</p><p>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。</p><p>而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</p><p>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p></blockquote><p>关于引用计数，简单点理解：</p><p><strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数<code>+1</code>，减持时<code>-1</code>，下次垃圾回收器会回收次数为<code>0</code>的值的内存（当然了，容易出循环引用的bug）</strong></p><p><strong>GC的缺陷</strong></p><p>和其他语言一样，javascript的GC策略也无法避免一个问题： <strong>GC时，停止响应其他操作</strong></p><p>这是为了安全考虑。</p><p>而Javascript的GC在<code>100ms</code>甚至以上</p><p>对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。</p><p>这就是引擎需要优化的点： <strong>避免GC造成的长时间停止响应。</strong></p><p><strong>GC优化策略</strong></p><p>这里介绍常用到的：<strong>分代回收（Generation GC）</strong></p><p>目的是通过区分“临时”与“持久”对象:</p><ul><li>多回收“临时对象”区（<code>young generation</code>）</li><li>少回收“持久对象”区（<code>tenured generation</code>）</li><li>减少每次需遍历的对象，从而减少每次GC的耗时。</li></ul><p>像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）</p><p>更多可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/33816534" target="_blank" rel="noopener">V8 内存浅析</a></p><h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><h4 id="可以提到跨域"><a href="#可以提到跨域" class="headerlink" title="可以提到跨域"></a>可以提到跨域</h4><p>譬如发出网络请求时，会用AJAX，如果接口跨域，就会遇到跨域问题</p><p>可以参考：</p><p><a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a></p><h4 id="可以提到web安全"><a href="#可以提到web安全" class="headerlink" title="可以提到web安全"></a>可以提到web安全</h4><p>譬如浏览器在解析HTML时，有<code>XSSAuditor</code>，可以延伸到web安全相关领域</p><p>可以参考：</p><p><a href="https://segmentfault.com/a/1190000012693772" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系。</a></p><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>如可以提到<code>viewport</code>概念，讲讲物理像素，逻辑像素，CSS像素等概念</p><p>如熟悉Hybrid开发的话可以提及一下Hybrid相关内容以及优化</p><p>…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述这么多内容，目的是：<strong>梳理出自己的知识体系</strong></p><p>本文由于是前端向，所以知识梳理时有重点，很多其它的知识点都简述或略去了，重点介绍的模块总结：</p><ul><li>浏览器的进程/线程模型、JS运行机制（这一块的详细介绍链接到了另一篇文章）</li><li>http规范（包括报文结构，头部，优化，http2.0，https等）</li><li>http缓存（单独列出来，因为它很重要）</li><li>页面解析流程（HTML解析，构建DOM，生成CSS规则，构建渲染树，渲染流程，复合层的合成，外链的处理等）</li><li>JS引擎解析过程（包括解释阶段，预处理阶段，执行阶段，包括执行上下文、VO、作用域链、this、回收机制等）</li><li>跨域相关，web安全单独链接到了具体文章，其它如CSS盒模型，viewport等仅是提及概念</li></ul><p>关于本文的价值？</p><p><strong>本文是个人阶段性梳理知识体系的成果</strong>，然后加以修缮后发布成文章，因此并不确保适用于所有人员</p><p>但是，个人认为本文还是有一定参考价值的</p><h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>还是那句话：<strong>知识要形成体系</strong></p><p>梳理出知识体系后，有了一个骨架，知识点不易遗忘，而且学习新知识时也会更加迅速，更重要的是容易举一反三，可以由一个普通的问题，深挖拓展到底层原理</p><p>前端知识是无穷无尽的，本文也仅仅是简单梳理出一个承载知识体系的骨架而已，更多的内容仍然需要不断学习，积累</p><p>另外，本文结合<a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a>这篇文章，更佳噢！</p><h2 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h2><ol><li><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2014/05/what-happen/</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li><li><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9666.html</a></li><li><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/" target="_blank" rel="noopener">http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/</a></li><li><a href="https://blog.csdn.net/dojiangv/article/details/51794535" target="_blank" rel="noopener">https://blog.csdn.net/dojiangv/article/details/51794535</a></li><li><a href="https://bbs.csdn.net/topics/340204423" target="_blank" rel="noopener">https://bbs.csdn.net/topics/340204423</a></li><li><a href="https://segmentfault.com/a/1190000004246731" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004246731</a></li><li><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2014/05/what-happen/</a></li><li><a href="http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html" target="_blank" rel="noopener">http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html</a></li><li><a href="https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html" target="_blank" rel="noopener">https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      近日在segmentfault社区看到了这么一篇文章，基于前端面试中很常问的一个题目--从输入URL到页面加载发生了什么，作者由此引出了在前端方向上的理应搭建起来的知识体系，深受触动，特此于文章基础上整理一番以梳理一下自身的前端知识体系。
    
    </summary>
    
      <category term="前端杂烩" scheme="http://alvabill.ml/categories/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="JavaScript" scheme="http://alvabill.ml/tags/JavaScript/"/>
    
      <category term="HTTP" scheme="http://alvabill.ml/tags/HTTP/"/>
    
      <category term="浏览器" scheme="http://alvabill.ml/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="CSS" scheme="http://alvabill.ml/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>最全Javascript数据类型解析</title>
    <link href="http://alvabill.ml/%E6%9C%80%E5%85%A8Javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://alvabill.ml/最全Javascript数据类型解析/</id>
    <published>2018-03-13T05:55:05.000Z</published>
    <updated>2018-09-07T05:51:53.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>最新的 ECMAScript 标准定义了 7 种数据类型：</p><ol><li>6种原型数据类型（primitive type）:</li></ol><ul><li>undefined.  变量未定义时的属性。</li><li>null. 一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL或其他变量完全不同。</li><li>Boolean.  布尔值，true 和 false.</li><li>Number.  表示数字，例如： 42 或者 3.14159。</li><li>String.  表示字符串，例如：”Howdy”</li><li>Symbol ( 在 ECMAScript 6 中新添加的类型).。一种数据类型，它的实例是唯一且不可改变的。</li></ul><ol start="2"><li>以及 Object 对象。（complex type 复杂类型）</li></ol><h3 id="undefined-类型"><a href="#undefined-类型" class="headerlink" title="undefined 类型"></a>undefined 类型</h3><p>Undefined类型只有一个值<code>undefined</code>，表示”缺少值”，就是此处应该有一个值，但是还没有定义。主要的用法：</p><blockquote><p>（1）变量被声明了，但没有赋值时，就等于undefined。<br>（2)  调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>（3）对象没有赋值的属性，该属性的值为undefined。<br>（4）函数没有返回值时，默认返回undefined。<br>   PS: 值 undefined 并不同于未定义的值。但是，typeof 运算符并不真正区分这两种值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="built_in">console</span>.log(i) ; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</span><br><span class="line">f();  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(o.p);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = f();</span><br><span class="line"><span class="built_in">console</span>.log(func);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y); <span class="comment">//"undefined"</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="null-类型"><a href="#null-类型" class="headerlink" title="null 类型"></a>null 类型</h3><p>null类型的默认值是<code>null</code>，从逻辑角度讲，是表示一个空对象指针，表示”没有对象”，即该处不应该有值。主要用法：</p><blockquote><p>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)  <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>区别undefined：</p><blockquote><p>当一个变量声明后，未初始化，则该值为undefined，如果这个值是为了保存对象，则修改其默认初始化的值，改为null。 所以当检测其类型时，会显示类型为object。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// object (历史原因，不是'null')</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// "undefined"</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span>  == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>布尔类型，该类型有两个值：<code>true</code> <code>false</code>。Bloolean()函数，可以将其他类型的值转换为布尔类型。同时也存在隐式类型转换。</p><blockquote><p>这里区分一下Truthy类型和Falsy类型值。<br>Falsy类型值包括：<code>&quot;&quot;</code>, <code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>false</code>。<br>除了Falsy类型值以外的都被称为Truthy类型值，它们会被转换为 <code>true</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>)         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'hello'</span>)      <span class="comment">// true </span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'0'</span>)          <span class="comment">// true </span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">' '</span>)          <span class="comment">// true </span></span><br><span class="line"><span class="built_in">Boolean</span>([])           <span class="comment">// true </span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h4><p><em>根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1）。<strong>它并没有为整数给出一种特定的类型</strong>。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。</em><br>整数可以用十进制（基数为10）、十六进制（基数为16）、八进制（基数为8）以及二进制（基数为2）的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F%28Array_literals%29" target="_blank" rel="noopener">字面值</a>来表示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">117</span> and <span class="number">-345</span> (十进制, 基数为<span class="number">10</span>)</span><br><span class="line"><span class="number">015</span>, <span class="number">0001</span> and <span class="number">-0</span>o77 (八进制, 基数为<span class="number">8</span>) </span><br><span class="line"><span class="number">0x1123</span>, <span class="number">0x00111</span> and <span class="number">-0xF1A7</span> (十六进制, 基数为<span class="number">16</span>或<span class="string">"hex"</span>)</span><br><span class="line"><span class="number">0b11</span>, <span class="number">0b0011</span> and <span class="number">-0</span>b11 (二进制, 基数为<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>浮点数（有趣的一点是，在计算前其存储为字符串）所占据的内存空间是整数的两倍。<br>语法：<code>[(+|-)][digits][.digits][(E|e)[(+|-)]digits]</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span>      </span><br><span class="line"><span class="number">-.2345789</span> <span class="comment">// -0.23456789</span></span><br><span class="line"><span class="number">-3.12e+12</span>  <span class="comment">// -3.12*1012</span></span><br><span class="line"><span class="number">.1e-23</span>    <span class="comment">// 0.1*10-23=10-24=1e-24</span></span><br></pre></td></tr></table></figure></p><p>NaN:<br>1、即非数值，是一个特殊的值，这个数值用于表示一个本来要返回数值的操作数，未返回数值的情况。比如任何数值除以0，本是不符合规范的，js里，这样的操作返回<code>NaN</code>（但是实际上，只有0除以0时返回<code>NaN</code>，其他则无穷值）。</p><p>2、<code>NaN</code>有两个不同寻常的特点：任何涉及<code>NaN</code>的操作都会返回<code>NaN</code>，<code>NaN</code>值与任何值都不相等，包括本身。<br>3、<code>isNaN()</code>函数，这个函数可以判断，传递的参数是否“不是数值”这里涉及数值转换的问题，例如<code>“10”</code>这个字符串就可以转换为<code>10</code>，但是<code>“blue”</code>这个字符串则无法转换为数字，所以<code>isNaN(&quot;blue&quot;)==true</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>  <span class="comment">//true</span></span><br><span class="line"><span class="number">42</span> / +<span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">42</span> / <span class="number">-0</span>; <span class="comment">// -Infinity</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><p>+Infinity，-Infinity:<br><em>要检查值是否大于或小于 <code>+/-Infinity</code>，你可以使用常量 <code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code>。另外在 ECMAScript 6 中，你也可以通过 <code>Number.isSafeInteger()</code> 方法还有 <code>Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER</code> 来检查值是否在双精度浮点数的取值范围内。 超出这个范围，JavaScript 中的数字不再安全了，也就是只有 second mathematical interger 可以在 JavaScript 数字类型中正确表现。</em></p><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>这个算是比较熟悉的了这里引用一下<a href="https://developer.mozilla.org/" target="_blank" rel="noopener">MDN</a>的描述。<br>JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量。<br>不同于类 C 语言，JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对原始字符串的操作来创建新的字符串。<br>主要强调一下ES2015的模板字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Basic literal string creation</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiline strings</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String interpolation</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Construct an HTTP request prefix is used to interpret the replacements and construction</span></span><br><span class="line">POST<span class="string">`http://foo.org/bar?a=<span class="subst">$&#123;a&#125;</span>&amp;b=<span class="subst">$&#123;b&#125;</span></span></span><br><span class="line"><span class="string">     Content-Type: application/json</span></span><br><span class="line"><span class="string">     X-Credentials: <span class="subst">$&#123;credentials&#125;</span></span></span><br><span class="line"><span class="string">     &#123; "foo": <span class="subst">$&#123;foo&#125;</span>,</span></span><br><span class="line"><span class="string">       "bar": <span class="subst">$&#123;bar&#125;</span>&#125;`</span>(myOnReadyStateChangeHandler);</span><br></pre></td></tr></table></figure></p><blockquote><p><code>String()</code>函数可以将任何类型的值转换为字符串，包括<code>null</code>转换为<code>&#39;null&#39;</code>、<code>undefined</code>转换为<code>&#39;undefined&#39;</code>。</p></blockquote><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>语法：<code>Symbol([description])</code><br>1、每个从Symbol()返回的symbol值都是唯一的。<br>直接使用Symbol()创建新的symbol类型，并用一个字符串（可省略）作为其描述。以下代码创建了三个新的symbol类型。 字符串 “foo” 的作用仅为描述，它每次都会创建一个新的 symbol类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"foo"</span>) === <span class="built_in">Symbol</span>(<span class="string">"foo"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>还可以使用<code>Symbol.for</code>方法创建新的symbol类型，和前者区别<code>Symbol.for()</code>会把symbol值以一个key值登记到全局环境中，<code>Symbol()</code>就不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。查看登记的Symbol值可以使用<code>Symbol.keyFor</code>方法，该方法返回一个已登记的 Symbol 类型值的key。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> sym3 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> sym4 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line">sym1 === sym2  <span class="comment">//false</span></span><br><span class="line">sym3 === sym4  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(sym1) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(sym3) <span class="comment">//"foo"</span></span><br></pre></td></tr></table></figure></p><p>2、 不再支持new 运算符的语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></p><p>这会阻止创建一个显式的 Symbol 包装器对象而不是一个 Symbol 值。围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number因为遗留原因仍可被创建。</p><p>3、特殊的类型转换<br>Symbol 值不能与其他类型的值进行运算。<br>Symbol 值可以显式转为字符串、布尔值，但是不能转为数值。</p><p>4、用于对象属性名（主要）<br>Symbol 值作为对象属性名时，不能用点运算符。一般通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> sym3 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [sym1]: <span class="string">'Symbol1'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">a[sym2] = <span class="string">'Symbol2'</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, sym3, &#123; <span class="attr">value</span>: <span class="string">'Symbol3'</span> &#125;);</span><br><span class="line"></span><br><span class="line">a.sym1 = <span class="string">'Hello!'</span>;</span><br><span class="line">a[sym1] <span class="comment">// "Symbol1"</span></span><br><span class="line">a[<span class="string">'sym1'</span>] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure></p><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><blockquote><p>更多的Symbol相关内容参考这篇文章——<a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">传送门</a></p></blockquote><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>在计算机科学中, 对象是指内存中的可以被标识符引用的一块区域。<br>对象属于复杂数据类型，也可以说是引用类型（逻辑上等价于class/类）。相对于原始数据类型的直接存取（栈内存），复杂数据类型的存储方式为引用（堆内存，栈内存保存对应的指针）。</p><h4 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h4><p>ECMAScript 中的所有对象都由这个对象继承而来，Object 对象中的所有属性和方法都会出现在其他对象中，所以理解了 Object 对象，就可以更好地理解其他对象。<br>本文主要介绍以下几点：</p><ul><li>Object()作为函数以及Object()构造函数</li><li>Object静态方法</li><li>Object实例方法</li></ul><p>1、Object()与new Object()<br>Object函数可以把任意值转换为对象；<code>new Object()</code>则是生成新对象，可以简写为<code>{}</code>。除语义上的不同外，两者的用法相同，以下以<code>Object()</code>为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//以上语句等效，返回空对象</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="number">1</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="string">'foo'</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="literal">true</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>如果参数本来就是一个对象便不需要转换，直接返回该对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(arr); <span class="comment">// 返回原数组</span></span><br><span class="line">obj === arr <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(value) <span class="comment">// 返回原对象</span></span><br><span class="line">obj === value <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(fn); <span class="comment">// 返回原函数</span></span><br><span class="line">obj === fn <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>2、Object静态方法<br>所谓“静态方法”，是指部署在Object对象自身的方法。例如：<code>Object.key = value</code>、<code>{key:value}</code>。<br>一般使用<code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法来遍历对象的属性。区别在于后者可以列举不可枚举的属性名，例如数组的<code>length</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'Hello'</span>, <span class="string">'World'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a) <span class="comment">// ["0", "1"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a) <span class="comment">// ["0", "1", "length"]</span></span><br></pre></td></tr></table></figure></p><p>其他静态方法：(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">传送门</a>)<br>1）对象属性模型的相关方法</p><ul><li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener"><code>Object.defineProperty()</code></a>：通过描述对象，定义某个属性。定义key为Symbol的属性的方法之一。</li><li><code>Object.defineProperties()</code>：通过描述对象，定义多个属性。</li></ul><p>2）控制对象状态的方法</p><ul><li><code>Object.preventExtensions()</code>：防止对象扩展。</li><li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li><li><code>Object.seal()</code>：禁止对象配置。</li><li><code>Object.isSealed()</code>：判断一个对象是否可配置。</li><li><code>Object.freeze()</code>：冻结一个对象。</li><li><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</li></ul><p>3）原型链相关方法</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener"><code>Object.assign(target, ...sources)</code></a>：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener"><code>Object.create()</code></a>：该方法可以指定原型对象和属性，返回一个新的对象。</li><li><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象。</li></ul><p>3、Object实例方法<br>定义在<code>Object.prototype</code>的·对象称为实例方法，所有Object的实例对象都继承了这些方法。<br><code>Object</code>实例对象的方法，主要有以下六个。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" target="_blank" rel="noopener"><code>Object.prototype.valueOf()</code></a>：返回当前对象对应的值。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener"><code>Object.prototype.toString()</code></a>：返回当前对象对应的字符串形式。<strong>检测对象类型。</strong></li><li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</li><li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li><li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li><li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li></ul><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><p>之所以会说到这个判断问题，主要原因是<code>typeof</code>是不太靠谱的。首先JavaScript是动态数据类型的语言，很多类型检查是不必要的。在具体实现上的问题，在实际的项目应用中，<code>typeof</code>也只有两个用途，就是检测一个元素是否为<code>undefined</code>，或者是否为<code>function</code>。由下面的表格可见一斑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Value               function   typeof</span><br><span class="line">-------------------------------------</span><br><span class="line">&quot;foo&quot;               String     string</span><br><span class="line">new String(&quot;foo&quot;)   String     object</span><br><span class="line">1.2                 Number     number</span><br><span class="line">new Number(1.2)     Number     object</span><br><span class="line">true                Boolean    boolean</span><br><span class="line">new Boolean(true)   Boolean    object</span><br><span class="line">new Date()          Date       object</span><br><span class="line">new Error()         Error      object</span><br><span class="line">[1,2,3]             Array      object</span><br><span class="line">new Array(1, 2, 3)  Array      object</span><br><span class="line">new Function(&quot;&quot;)    Function   function</span><br><span class="line">/abc/g              RegExp     object</span><br><span class="line">new RegExp(&quot;meow&quot;)  RegExp     object</span><br><span class="line">&#123;&#125;                  Object     object</span><br><span class="line">new Object()        Object     object</span><br></pre></td></tr></table></figure></p><p>如果还是要判断的话，公认的靠谱解法是 <code>Object.prototype.toString.call(x) === &#39;[object type]&#39;</code>。具体实现可以参考<code>jQuery.type()</code>源码。另外通过构造函数创建的对象都可以用 <code>instanceof</code> 检查。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/31759933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31759933</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol</a></li><li><a href="https://javascript.ruanyifeng.com/stdlib/object.html" target="_blank" rel="noopener">https://javascript.ruanyifeng.com/stdlib/object.html</a></li><li><a href="https://segmentfault.com/q/1010000000464600" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000464600</a></li></ol>]]></content>
    
    <summary type="html">
    
      总结了一下最新标准下的javaScript数据类型，也算是好好复习总结了一下。
    
    </summary>
    
      <category term="JavaScript" scheme="http://alvabill.ml/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://alvabill.ml/tags/JavaScript/"/>
    
      <category term="ECMAScript" scheme="http://alvabill.ml/tags/ECMAScript/"/>
    
      <category term="EC6+" scheme="http://alvabill.ml/tags/EC6/"/>
    
  </entry>
  
  <entry>
    <title>forEach方法跳出循环</title>
    <link href="http://alvabill.ml/forEach%E6%96%B9%E6%B3%95%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF/"/>
    <id>http://alvabill.ml/forEach方法跳出循环/</id>
    <published>2018-03-11T02:05:07.000Z</published>
    <updated>2018-09-07T05:51:53.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>没怎么理解JavaScript的<code>forEach</code>方法的童鞋使用<code>forEach</code>时很容易遇到一个问题就是，当你想要跳出这个循环时，发现<code>return</code>、<code>break</code>是不起作用的。下面我们来分析一下原因以及解决方法。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先我们要知道的是<code>forEach</code>方法的机制是对数组的每个有效元素执行一次<code>callback</code>函数，然后<code>return</code>、<code>break</code>等只作用于一个函数，也就造成了无法跳出<code>forEach</code>循环的问题，而是只能跳过当前函数的执行。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="曲线救国（SegmentFault）"><a href="#曲线救国（SegmentFault）" class="headerlink" title="曲线救国（SegmentFault）"></a>曲线救国（<a href="https://segmentfault.com/q/1010000003866554" target="_blank" rel="noopener">SegmentFault</a>）</h4><p>通过使用抛出异常的方式可以中止。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arr ,item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> BreakException= &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i === item) <span class="keyword">throw</span> BreakException;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"><span class="keyword">if</span> (e!==BreakException) <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Array-some-amp-Array-every"><a href="#Array-some-amp-Array-every" class="headerlink" title="Array.some&amp;Array.every"></a>Array.some&amp;Array.every</h4><p>正常的使用环境：如果是测试一个数组里的元素是否符合某条件，且需要返回一个布尔值则应该使用这两个方法。这里可用于跳出循环。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arr ,item</span>)</span>&#123;</span><br><span class="line">arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i === item) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arr ,item</span>)</span>&#123;</span><br><span class="line">arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i === item) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循规蹈矩"><a href="#循规蹈矩" class="headerlink" title="循规蹈矩"></a>循规蹈矩</h4><p>如果你需要这样，使用forEach()方法是错误的，你可以用一个简单的循环作为替代。—— <em>MDN</em><br>对于多重for循环，我们跳出循环需要特殊处理一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xh:<span class="comment">//首先将循环命名</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">3</span> &amp;&amp; j==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> xh;<span class="comment">//跳出循环xh</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/q/1010000003866554" target="_blank" rel="noopener">https://segmentfault.com/q/1010000003866554</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach</a></li></ol>]]></content>
    
    <summary type="html">
    
      这些天使用forEach遍历一个数组时发现的一个问题——forEach循环数组时无法通过return、break的方式跳出循环，特此深入了解了一下forEach的机制。
    
    </summary>
    
      <category term="JavaScript" scheme="http://alvabill.ml/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://alvabill.ml/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客--SEO和站点加速</title>
    <link href="http://alvabill.ml/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-SEO%E5%92%8C%E7%AB%99%E7%82%B9%E5%8A%A0%E9%80%9F/"/>
    <id>http://alvabill.ml/hexo搭建个人博客-SEO和站点加速/</id>
    <published>2018-02-25T16:14:43.000Z</published>
    <updated>2018-09-07T05:51:52.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文为hexo搭建个人博客系列教程的第三篇，主要内容为网站的SEO以及站点访问加速，前两篇分别为<a href="https://alvabill.ml/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2--%E5%9F%BA%E7%A1%80%E7%AF%87/">基础篇</a>以及<a href="https://alvabill.ml/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-NexT%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/">主题优化篇</a>，由于网站是基于hexo的Next主题，所以建议读者按系列教程的步骤来配置，不过本文中的大部分配置是可以各类网站通用的，所以依旧具备极大的参考价值。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="站点收录"><a href="#站点收录" class="headerlink" title="站点收录"></a>站点收录</h3><p>一般来说你的网站搭建好后依旧是无法在各大搜索引擎中搜到的，具体可以通过在搜索引擎输入<code>site:你的域名</code>验证。<br>所以你需要提交你的站点到各大搜索引擎：</p><ul><li><a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">百度提交入口</a></li><li><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">Google提交入口</a></li></ul><blockquote><p>github禁止百度爬虫，所以使用coding pages才能被百度收录！！（博主为github/coding同步配置，所以并未验证）</p></blockquote><h4 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h4><p>在<a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">百度站长</a>处提交你的站点后进行网站所以权验证，一般有三种方法：文件验证、HTML标签验证和CNAME验证。</p><h5 id="文件验证"><a href="#文件验证" class="headerlink" title="文件验证"></a>文件验证</h5><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520221350505.jpg" alt=""></p><p>一般网站如上图步骤配置，基于hexo的站点则：<br>1 需要先下载验证文件，将下载的文件放到<code>站点根目录/source</code>文件下<br>2 在<strong>站点配置文件</strong>中找到<code>skip_render:</code>修改：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">README.md</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">CNAME</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">baidu_verify_XXXXXXXXXX.html</span> <span class="comment">#下载的文件名</span></span><br></pre></td></tr></table></figure></p><p>3 <code>hexo g -d</code>重新渲染部署网站<br>4 点击百度站长文件验证步骤3，确认验证</p><h5 id="HTML标签验证"><a href="#HTML标签验证" class="headerlink" title="HTML标签验证"></a>HTML标签验证</h5><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520222376404.jpg" alt=""></p><p>1 把图中马赛克部分的<code>token</code>复制下来<br>2 打开<strong>主题配置文件</strong>，搜索<code>site_verification</code>，修改：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Google Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters/</span></span><br><span class="line"><span class="attr">google_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">baidu_site_verification:</span><span class="string">&#123;your</span> <span class="string">token&#125;</span></span><br></pre></td></tr></table></figure></p><p>3 保存重新渲染部署网站即可</p><h5 id="CNAME验证"><a href="#CNAME验证" class="headerlink" title="CNAME验证"></a>CNAME验证</h5><p>对于已经绑定域名的站点，这种方式最简单！</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520222887078.jpg" alt=""></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520222981213.jpg" alt=""></p><p>主机记录填入马赛克部分（<code>token</code>），保存即可。</p><h4 id="google收录"><a href="#google收录" class="headerlink" title="google收录"></a>google收录</h4><p>推荐HTML标签验证，具体同百度收录部分。</p><hr><h3 id="添加站点地图sitemap"><a href="#添加站点地图sitemap" class="headerlink" title="添加站点地图sitemap"></a>添加站点地图sitemap</h3><p>安装<code>hexo</code>的<code>sitemap</code>网站地图生成插件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save</span><br><span class="line">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></p><p>在<strong>站点配置文件</strong>中添加如下代码:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span> </span><br><span class="line"><span class="attr">  path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure></p><p>配置成功后，会生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>，前者适合提交给谷歌搜素引擎，后者适合提交百度搜索引擎。<br>百度站长管理–&gt;链接提交：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520224175482.jpg" alt=""></p><p>Google站长管理–&gt;站点地图：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520224517827.jpg" alt=""></p><h3 id="百度主动推送"><a href="#百度主动推送" class="headerlink" title="百度主动推送"></a>百度主动推送</h3><p>安装主动推送插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure></p><p>在<strong>站点配置文件</strong>中添加以下内容：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line"><span class="attr">  count:</span> <span class="number">3</span> <span class="comment">## 比如3，代表提交最新的三个链接</span></span><br><span class="line"><span class="attr">  host:</span> <span class="string">alvabill.ml</span> <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line"><span class="attr">  token:</span> <span class="string">&#123;your</span> <span class="string">token&#125;</span> <span class="comment">## 请注意这是您的秘钥，请不要发布在公众仓库里!</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">baidu_urls.txt</span> <span class="comment">## 文本文档的地址，新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure></p><p><code>token</code>位置：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520224828028.jpg" alt=""><br>另外在<strong>站点配置文件</strong>中确认<code>url</code>值是否为百度站长平台注册的域名，然后添加一个新的deploy的类型：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">baidu_url_submitter</span>  <span class="comment">##新添加</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">git@git.coding.net:Alvabill/Alvabill.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p><p>把<strong>主题配置文件</strong>中的<code>baidu_push</code>设置为<code>true</code>，重新渲染部署即可。</p><hr><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><h4 id="更改首页标题格式"><a href="#更改首页标题格式" class="headerlink" title="更改首页标题格式"></a>更改首页标题格式</h4><p>打开<code>\themes\next\layout\index.swig</code>文件，找到以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block title %&#125; </span><br><span class="line">...</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>把它改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block title %&#125;</span><br><span class="line">  &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="修改文章链接"><a href="#修改文章链接" class="headerlink" title="修改文章链接"></a>修改文章链接</h4><p>hexo默认文章链接太长，不利于SEO，建议修改为<code>domain/postname</code>的形式:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="七牛云存储图片"><a href="#七牛云存储图片" class="headerlink" title="七牛云存储图片"></a>七牛云存储图片</h3><p>进入<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛官网</a>注册账号<br>进入管理控制台，新建对象存储空间：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520225841086.jpg" alt=""></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520225890350.jpg" alt=""></p><p>图片上传和使用：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1520226012880.jpg" alt=""></p><blockquote><p>博客中的图片可以通过别的Markdown编辑平台（例如小书匠）即时上传到绑定的七牛云上边，加速站点的同时方便博客迁移。</p></blockquote><hr><h3 id="更改默认Google字体库"><a href="#更改默认Google字体库" class="headerlink" title="更改默认Google字体库"></a>更改默认Google字体库</h3><p>用国内的CDN库来替代主题中的google字体库，到<strong>站点配置文件</strong>中设置默认字体库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host: fonts.useso.com</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>很折腾不过也还是收获满满，期间了解到了网上非常多的资源站点以及插件站点，开启了一种新的项目思路，可以说这期间的折腾都非常值得的了，而且做这么一个博客网站除了赏心悦目外最要紧的是，起到了一个很好的督促写作的功能，也象征着个人的博客生涯正式开启，说到写博客吧，一是记录二是分享，更多的还是希望和更多的人交流，希望在这个互联网时代和大家多交流学习共同进步，学无止境，继续加油。</p>]]></content>
    
    <summary type="html">
    
      博客基本搭建完成后还需要做的就是收录、SEO还有站点的加速了。本篇算是hexo搭建个人博客系列的终篇，主要分享的就是以上几点。
    
    </summary>
    
      <category term="建站" scheme="http://alvabill.ml/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="hexo" scheme="http://alvabill.ml/tags/hexo/"/>
    
      <category term="SEO" scheme="http://alvabill.ml/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客--NexT主题优化</title>
    <link href="http://alvabill.ml/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-NexT%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
    <id>http://alvabill.ml/hexo搭建个人博客-NexT主题优化/</id>
    <published>2018-02-22T03:57:23.000Z</published>
    <updated>2018-09-07T05:51:52.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文为个人前一篇文章<a href="https://alvabill.ml/2018/01/30/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2--%E5%9F%BA%E7%A1%80%E7%AF%87/">hexo搭建个人博客–基础篇</a>的后续篇，前文主要介绍了如何搭建一个个人网站以及绑定域名等相关内容，还没有建站的伙伴们可以看一下前文，已经搭建好的就可以忽略了。<br>本文的优化是基于Hexo的NexT主题的，其他主题的疑问也可以在后台或评论区一起沟通交流。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1 实用性优化</p><ul><li>基本使用（<code>_config.yml</code>文件配置）</li><li>添加RSS</li><li>添加标签、分类等页面</li><li>设置网站icon</li><li>添加侧边栏社交链接</li><li>添加侧边栏友情链接</li><li>底部显示建站时间和图标的修改</li><li>微信支付宝打赏功能</li><li>关闭网站动画效果</li><li>设置第三方JS库</li><li>添加评论系统</li><li>统计访客量以及文章阅读量</li><li>阅读次数统计（基于LanCloud）</li><li>字数统计</li><li>增加版权信息</li><li>添加文章分享功能</li><li>文章排序优先级设置</li><li>添加站内搜索功能</li><li>DaoVoice在线联系</li></ul><p>2 个性化优化</p><ul><li>设置字体</li><li>设置代码高亮主题</li><li>左上角或右上角的Github样式</li><li>添加背景动画</li><li>添加顶部加载条</li><li>点击出现小爱心效果</li><li>修改文章链接文本样式</li><li>修改文章底部标签样式</li><li>文章末尾统一添加“文本结束”标记</li><li>修改作者头像并旋转</li><li>文章添加阴影效果</li><li>修改打赏部分字体动画</li><li>自定义鼠标样式</li><li>添加看板娘</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>以下修改保存后均可通过<code>hexo g &amp;&amp; hexo s</code>指令在本地<code>http://localhost:4000</code>查看修改，另外通过<code>hexo d</code>发布到GitHub pages 或 Coding pages上面通过绑定的域名在线查看效果。</p><h2 id="实用性优化"><a href="#实用性优化" class="headerlink" title="实用性优化"></a>实用性优化</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><blockquote><p>上一篇文章已经讲过如何安装Hexo，不了解的小伙伴可以参考一下我的上一篇文章，或者访问<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo文档</a>来了解如何安装Hexo。</p></blockquote><p>在Hexo中有两个很重要的名为<code>_config.yml</code>的文件，其中一个在站点安装的根目录下，另一个在主题目录下。前者提供了Hexo自身的一些基本配置信息，后者为你所安装的主题的相关配置。为了方便区分，我们把前者称为<strong>站点配置文件</strong>，后者称为<strong>主题配置文件</strong>。</p><h4 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h4><p>文件路径<code>站点根目录/_config.yml</code>，编辑软件推荐使用Sublime Text 。<br>这里贴一下个人的部分配置，可以改一下相关内容自行体会一下效果：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Alvabill</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Stay</span> <span class="string">Hungry,</span> <span class="string">Stay</span> <span class="string">Foolish</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Alvabill</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"Alvabill个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面"</span>  <span class="comment">#网站描述 SEO</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure></p><p>“title”：博客的名称。<br>“subtitle”：根据主题的不同，有的会显示有的不会显示。<br>“description”：主要用于SEO，告诉搜索引擎一个关于站点的简单描述，通常建议在其中包含网站的关键词。<br>“author”：作者名称，用于主题显示文章的作者。<br>“language”：语言会对应的解析正在应用的主题中的languages文件夹下的不同语言文件。所以这里的名称要和languages文件夹下的语言文件名称一致。<br>“timezone”：可不填写。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://alvabill.ml</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>“url”：一般填写自己的站点链接。<br>“root”：设置根目录的位置。如果你的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则应该将你的 url 设为<code>http://yoursite.com/blog</code> 并把 root 设为 <code>/blog/</code>。<br>“permalink”：生成的链接的格式。带井号的是默认的格式，带有日期感觉怪怪的，改成了自己喜欢的格式。规则也比较简单，标签前面要加英文冒号。<br>“permalink_defaults”:  生成链接中各部分的默认值</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">README.md</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">CNAME</span></span><br></pre></td></tr></table></figure><p>目录一般不需要修改，这里需要改动的是<code>skip_render</code>，跳过指定文件的渲染，这里写上去着两个文件名便可，在上一篇文章中已经详细描述过这里就不累赘了。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br></pre></td></tr></table></figure><p>书写相关的设置<br>“new_post_name”：新的博文的文件名<br>“default_layout:“ 默认布局<br>“filename_case: 0“ #把文件名称转换为 (1) 小写或 (2) 大写<br>“render_drafts: false“ 是否显示草稿<br>“post_asset_folder: false“ #是否启动资源文件夹<br>“relative_link: false“ #把链接改为与根目录的相对位址<br>“future: true “<br>“highlight:“ #代码块的设置，Hexo自带的代码高亮插件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br></pre></td></tr></table></figure><p>分类和标签的设置<br>“default_category”：如果撰写文章时没有设置分类，默认的分类选择。<br>“category_map”：用于映射分类的别名。<br>“tag_map”：用法和分类别名是一样的。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span></span><br><span class="line"><span class="attr">    github:</span> <span class="string">git@github.com:Alvabill/Alvabill.github.io.git,master</span></span><br><span class="line"><span class="attr">    coding:</span> <span class="string">git@git.coding.net:Alvabill/Alvabill.git,master</span></span><br></pre></td></tr></table></figure><p>“theme”：主题拓展，可以在主题商店选择其他主题，这里使用next<br>“deploy”：部署方式，<a href="https://alvabill.ml/2018/01/30/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2--%E5%9F%BA%E7%A1%80%E7%AF%87/">前文</a>已经详细描述，不再累赘。</p><h4 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h4><p>文件路径<code>站点根目录/themes/next/_config.yml</code>，编辑软件推荐使用Sublime Text 。<br>这里先选择主题：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes  # NexT 主题提供三种布局</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure></p><p>主题选择，在前面加<code>#</code>注释掉其他的，这里我们选Mist，其他主题你们也可以体验一下，不过不保证本教程的优化全部适配哦，不过选择其他主题的小伙伴遇到的问题也欢迎在评论区提出一起交流。</p><hr><h3 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h3><p>在<strong>主题配置文件</strong>中有NexT默认的RSS设置，默认为留空，这时使用 Hexo 生成的 Feed 链接，需要先安装 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a>插件。<br>在站点根目录打开git bash，安装插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure></p><p>修改<strong>站点配置文件</strong>，在最后添加以下代码：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span> <span class="comment"># RSS订阅插件</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">plugins:</span> <span class="string">hexo-generate-feed</span></span><br></pre></td></tr></table></figure></p><p>修改<strong>主题配置文件</strong>如下：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure></p><p>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519390897568.jpg" alt="enter description here"></p><hr><h3 id="添加标签、分类等页面"><a href="#添加标签、分类等页面" class="headerlink" title="添加标签、分类等页面"></a>添加标签、分类等页面</h3><p>1 修改<strong>主题配置文件</strong>，在菜单项添加以下内容：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml</span></span><br><span class="line">  <span class="comment">#commonweal: /404/</span></span><br></pre></td></tr></table></figure></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519391446050.jpg" alt="enter description here"></p><blockquote><p>这里可以添加图标，个人不是很喜欢所以没有添加，图标的代码就在以上代码的下边，可以自行修改体验。</p></blockquote><p>2 新建页面<br>在站点根目录输入以下代码新建页面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags</span><br><span class="line">$ hexo new page categories</span><br><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure></p><p><code>archives</code>页面不需要新建，NexT主题自带了；tags、categories页面需要设置类型，即打开<code>站点根目录\source\tags</code>、<code>站点根目录\source\categories</code>分别进行修改：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519392168924.jpg" alt="enter description here"></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519392119211.jpg" alt="enter description here"></p><blockquote><p>如果有集成评论服务，页面也会带有评论。因为后面我们会添加评论系统所以这里需要添加字段 comments 并将值设置为 false。</p></blockquote><hr><h3 id="设置网站icon"><a href="#设置网站icon" class="headerlink" title="设置网站icon"></a>设置网站icon</h3><p><strong>主题配置文件</strong>中第一行代码就是网站icon设置，这里你只需要找到你喜欢的logo把它制作成ico格式然后改名<code>favicon.ico</code>，放到<code>/themes/next/source/images</code>下面即可。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Put your favicon.ico into `hexo-site/source/` directory.</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span> <span class="comment"># 网站logo</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="添加侧边栏社交链接"><a href="#添加侧边栏社交链接" class="headerlink" title="添加侧边栏社交链接"></a>添加侧边栏社交链接</h3><p>主要修改<strong>主题配置文件</strong>的社交链接和对应图标：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Social Links</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value is the target link (E.g. GitHub: https://github.com/iissnan)</span></span><br><span class="line"><span class="attr">social:</span>  <span class="comment"># 添加你的社交账号</span></span><br><span class="line">  <span class="comment">#LinkLabel: Link</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="attr">https://github.com/Alvabill</span></span><br><span class="line"><span class="attr">  fcc:</span> <span class="attr">https://www.freecodecamp.cn/alvabill</span></span><br><span class="line">  <span class="string">简书:</span> <span class="attr">https://www.jianshu.com/u/439a6eee60e1</span></span><br><span class="line"><span class="attr">  CSDN:</span> <span class="attr">http://blog.csdn.net/weixin_38796712</span></span><br><span class="line"><span class="comment"># Social Links Icons</span></span><br><span class="line"><span class="comment"># Icon Mapping:</span></span><br><span class="line"><span class="comment">#   Map a menu item to a specific FontAwesome icon name.</span></span><br><span class="line"><span class="comment">#   Key is the name of the item and value is the name of FontAwesome icon. Key is case-senstive.</span></span><br><span class="line"><span class="comment">#   When an globe mask icon presenting up means that the item has no mapping icon.</span></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  icons_only:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  transition:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Icon Mappings.</span></span><br><span class="line">  <span class="comment"># KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome</span></span><br><span class="line"><span class="attr">  fcc:</span> <span class="string">free-code-camp</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="string">github</span></span><br><span class="line">  <span class="string">简书:</span> <span class="string">book</span></span><br><span class="line"><span class="attr">  CSDN:</span> <span class="string">rotate-right</span></span><br></pre></td></tr></table></figure></p><p>实现效果如下：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519394054058.jpg" alt="enter description here"></p><hr><h3 id="添加侧边栏友情链接"><a href="#添加侧边栏友情链接" class="headerlink" title="添加侧边栏友情链接"></a>添加侧边栏友情链接</h3><p>修改<strong>主题配置文件</strong>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Blog rolls  推荐阅读</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">Links</span></span><br><span class="line"><span class="comment">#links_layout: block</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">inline</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="string">Web前端导航:</span> <span class="attr">http://www.alloyteam.com/nav/</span></span><br><span class="line">  <span class="string">创造狮导航:</span> <span class="attr">http://www.chuangzaoshi.com/code</span></span><br><span class="line">  <span class="string">前端书籍资料:</span> <span class="attr">http://www.36zhen.com/t?id=3448</span></span><br><span class="line">  <span class="string">掘金酱:</span> <span class="attr">http://e.xitu.io/</span></span><br><span class="line"><span class="attr">  V2EX:</span> <span class="attr">https://www.v2ex.com/</span></span><br><span class="line">  <span class="string">印记中文:</span> <span class="attr">https://www.v2ex.com/</span></span><br></pre></td></tr></table></figure></p><p>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519394239052.jpg" alt="enter description here"></p><hr><h3 id="底部显示建站时间和图标修改"><a href="#底部显示建站时间和图标修改" class="headerlink" title="底部显示建站时间和图标修改"></a>底部显示建站时间和图标修改</h3><p>修改<strong>主题配置文件</strong>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Specify the date when the site was setup</span></span><br><span class="line"><span class="attr">since:</span> <span class="number">2018</span> <span class="comment"># 建站年份</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># icon between year and author @Footer</span></span><br><span class="line"><span class="attr">authoricon:</span> <span class="string">snowflake-o</span></span><br></pre></td></tr></table></figure></p><p>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519394523529.jpg" alt="enter description here"></p><blockquote><p>雪花图标需要用到最新的fa图标库，后面会介绍如何设置默认库。</p></blockquote><hr><h3 id="微信支付宝打赏功能"><a href="#微信支付宝打赏功能" class="headerlink" title="微信支付宝打赏功能"></a>微信支付宝打赏功能</h3><p>在<strong>主题配置文件</strong>中的微信or支付宝收款地址处填入收款二维码图片即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Reward</span><br><span class="line">#reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: http://p3dm71oa7.bkt.clouddn.com/wcpay.png</span><br><span class="line">alipay: http://p3dm71oa7.bkt.clouddn.com/zfbpay.jpg</span><br><span class="line">#bitcoin: /images/bitcoin.png</span><br></pre></td></tr></table></figure></p><p>实现效果：<br><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519395390692.jpg" alt="enter description here"></p><hr><h3 id="关闭网站动画效果"><a href="#关闭网站动画效果" class="headerlink" title="关闭网站动画效果"></a>关闭网站动画效果</h3><p>为了追求更快的响应速度我们可以把网站的大部分动画关掉，这里修改<strong>主题配置文件</strong>的一行代码即可：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Motion</span></span><br><span class="line"><span class="attr">use_motion:</span> <span class="string">[false/true]</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="设置第三方JS库"><a href="#设置第三方JS库" class="headerlink" title="设置第三方JS库"></a>设置第三方JS库</h3><p>在<strong>主题配置文件</strong>中设定成合适的 CDN 地址，此特性可以加速静态资源（JavaScript 第三方库）的加载。<br>例如：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Script Vendors.</span></span><br><span class="line"><span class="comment"># Set a CDN address for the vendor you want to customize.</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment">#    mquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js</span></span><br><span class="line"><span class="comment"># Be aware that you should use the same version as internal ones to avoid potential problems.</span></span><br><span class="line"><span class="comment"># Please use the https protocol of CDN files when you enable https on your site.</span></span><br><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="comment"># Internal path prefix. Please do not edit it.</span></span><br><span class="line"><span class="attr">  _internal:</span> <span class="string">lib</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 2.1.3</span></span><br><span class="line"><span class="attr">  jquery:</span> <span class="string">//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 2.1.5</span></span><br><span class="line">  <span class="comment"># See: http://fancyapps.com/fancybox/</span></span><br><span class="line"><span class="attr">  fancybox:</span> <span class="string">//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js</span></span><br><span class="line"><span class="attr">  fancybox_css:</span> <span class="string">//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.6</span></span><br><span class="line">  <span class="comment"># See: https://github.com/ftlabs/fastclick</span></span><br><span class="line"><span class="attr">  fastclick:</span> <span class="string">//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.9.7</span></span><br><span class="line">  <span class="comment"># See: https://github.com/tuupola/jquery_lazyload</span></span><br><span class="line"><span class="attr">  lazyload:</span> <span class="string">//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.2.1</span></span><br><span class="line">  <span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">  velocity:</span> <span class="string">//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.2.1</span></span><br><span class="line">  <span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">  velocity_ui:</span> <span class="string">//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 0.7.9</span></span><br><span class="line">  <span class="comment"># See: https://faisalman.github.io/ua-parser-js/</span></span><br><span class="line"><span class="attr">  ua_parser:</span> <span class="string">//cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 4.6.2</span></span><br><span class="line">  <span class="comment"># See: http://fontawesome.io/</span></span><br><span class="line"><span class="attr">  fontawesome:</span> <span class="string">//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1</span></span><br><span class="line">  <span class="comment"># https://www.algolia.com</span></span><br><span class="line"><span class="attr">  algolia_instant_js:</span></span><br><span class="line"><span class="attr">  algolia_instant_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.2</span></span><br><span class="line">  <span class="comment"># See: https://github.com/HubSpot/pace</span></span><br><span class="line">  <span class="comment"># Or use direct links below:</span></span><br><span class="line">  <span class="comment"># pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line">  <span class="comment"># pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line"><span class="attr">  pace:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="attr">  pace_css:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">  canvas_nest:</span> <span class="string">//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h3><p>NexT支持的第三方的评论系统有很多，不过不少已经关闭不再可用了，而且对于国内来说比较友好的现在应该就只有<a href="https://livere.com" target="_blank" rel="noopener">来必力</a>，当然喜欢折腾的小伙伴可以尝试一下其他的或者自建评论系统。这里就先介绍目前最简单可行的方案，也就是来必力。</p><p>获取来必力id：<br>登陆 <a href="https://livere.com/" target="_blank" rel="noopener">来必力</a> 注册获取，这里要注意，这个韩国的系统注册啥的真的太慢了，所以要记住不要耐不住关闭页面或者狂刷新，耐心等待就好。<br>注册后点击导航上边的安装，选择免费的city版本：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519486026113.jpg" alt="enter description here"><br>点击现在安装后填入网站的一些信息就可以获取到安装代码，框中的就是你的来必力id：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519486165098.jpg" alt="enter description here"></p><p>复制上边的id，在<strong>主题配置文件</strong>里面搜索<code>livere_uid</code>，在后面添加来必力id即可：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Support for LiveRe comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="attr">livere_uid:</span> <span class="string">&#123;你的来必力id&#125;</span></span><br></pre></td></tr></table></figure></p><p>另外可以点击用户头像进入管理界面个性化你的评论系统：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519486309368.jpg" alt="enter description here"></p><p>最终实现效果:</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519486370273.jpg" alt="enter description here"></p><hr><h3 id="统计访客量以及文章阅读量"><a href="#统计访客量以及文章阅读量" class="headerlink" title="统计访客量以及文章阅读量"></a>统计访客量以及文章阅读量</h3><p>NexT主题集成了不蒜子统计功能：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="comment"># 不蒜子统计功能</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line"><span class="attr">  site_uv:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="attr">  site_uv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line"><span class="attr">  site_pv:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="attr">  site_pv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line"><span class="attr">  page_pv:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="attr">  page_pv_footer:</span></span><br></pre></td></tr></table></figure></p><p>当<code>enable: true</code>时，代表开启全局开关。若<code>site_uv</code>、<code>site_pv</code>、<code>page_pv</code>的值均为<code>false</code>时，不蒜子仅作记录而不会在页面上显示。<br>当<code>site_uv: true</code>时，代表在页面底部显示站点的UV值。<br>当<code>site_pv: true</code>时，代表在页面底部显示站点的PV值。<br>当<code>page_pv: true</code>时，代表在文章页面的标题下显示该页面的PV值（阅读数）。<br><code>site_uv_header</code>和<code>site_uv_footer</code>这几个为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。<br>示例：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 效果：本站访客数12345人次</span></span><br><span class="line"><span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">site_uv_header:</span> <span class="string">本站访客数</span></span><br><span class="line"><span class="attr">site_uv_footer:</span> <span class="string">人次</span></span><br><span class="line"><span class="comment"># 效果：本站总访问量12345次（一般不开启这个）</span></span><br><span class="line"><span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">site_pv_header:</span> <span class="string">本站总访问量</span></span><br><span class="line"><span class="attr">site_pv_footer:</span> <span class="string">次</span></span><br><span class="line"><span class="comment"># 效果：本文总阅读量12345次</span></span><br><span class="line"><span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">page_pv_header:</span> <span class="string">本文总阅读量</span></span><br><span class="line"><span class="attr">page_pv_footer:</span> <span class="string">次</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="阅读次数统计（基于LeanCloud）"><a href="#阅读次数统计（基于LeanCloud）" class="headerlink" title="阅读次数统计（基于LeanCloud）"></a>阅读次数统计（基于LeanCloud）</h3><p>相比不蒜子的统计，<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>的文章阅读量统计更加稳定靠谱，所以本人也把网站的文章内统计改为LeanCloud的了。<br>设置方法参考该文章–<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">传送门</a></p><p>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519488690562.jpg" alt="enter description here"></p><hr><h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>用于统计文章的字数以及分析出阅读时间。<br>在<strong>主题配置文件</strong>中，搜索<code>wordcount</code>，设置为下面这样就可以了：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  min2read:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  wordcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>再打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>leancloud-visitors-count</code>后面位置添加一个分割符：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519489975360.jpg" alt="enter description here"><br>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519489219127.jpg" alt="enter description here"></p><p>另外，在<code>/themes/next/layout/_partials/footer.swig</code>文件<code>endif %}</code>前加上下面代码可以实现在站点底部统计全站字数：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-info"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>Total Words:&#123;&#123; totalcount(site) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519489555153.jpg" alt="enter description here"></p><p>如果无法显示可能是<code>hexo-wordcount</code>插件没有安装，git bash在网站根目录安装一下就可以：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><hr><h3 id="增加版权信息"><a href="#增加版权信息" class="headerlink" title="增加版权信息"></a>增加版权信息</h3><p>在目录<code>themes/next/layout/_macro/</code>下添加<code>my-copyright.swig</code>，代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.copyright %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my_post_copyright"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- JS库 sweetalert 可修改路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/sweetalert/dist/sweetalert.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>本文标题:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>文章作者:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">title</span>=<span class="string">"访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"</span>&gt;</span>&#123;&#123; theme.author &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>发布时间:<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>最后更新:<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>原始链接:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; page.title &#125;&#125;"</span>&gt;</span>&#123;&#123; page.permalink &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"copy-path"</span>  <span class="attr">title</span>=<span class="string">"点击复制文章链接"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-clipboard"</span> <span class="attr">data-clipboard-text</span>=<span class="string">"&#123;&#123; page.permalink &#125;&#125;"</span>  <span class="attr">aria-label</span>=<span class="string">"复制成功！"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>许可协议:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-creative-commons"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">"license"</span> <span class="attr">href</span>=<span class="string">"https://creativecommons.org/licenses/by-nc-nd/4.0/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"</span>&gt;</span>署名-非商业性使用-禁止演绎 4.0 国际<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 转载请保留原文链接及作者。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> clipboard = <span class="keyword">new</span> Clipboard(<span class="string">'.fa-clipboard'</span>);</span></span><br><span class="line"><span class="javascript">    $(<span class="string">".fa-clipboard"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      clipboard.on(<span class="string">'success'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">        swal(&#123;   </span></span><br><span class="line"><span class="javascript">          title: <span class="string">""</span>,   </span></span><br><span class="line"><span class="javascript">          text: <span class="string">'复制成功'</span>,</span></span><br><span class="line"><span class="javascript">          icon: <span class="string">"success"</span>, </span></span><br><span class="line"><span class="javascript">          showConfirmButton: <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">          &#125;);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined">    &#125;);  </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>在目录<code>themes/next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code>：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.my_post_copyright</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">85%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">45em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2.8em</span> auto <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1.0em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d3d3d3</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.93rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6em</span>;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> p&#123;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5.2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#b5b5b5</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.raw</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">a</span>:hover &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#a3d2a3</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span>:hover <span class="selector-class">.fa-clipboard</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.post-url</span>:hover &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.copy-path</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  +mobile()&#123;<span class="attribute">display</span>:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.copy-path</span>:hover &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改<code>themes/next/layout/_macro/post.swig</code>，在代码:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% include 'wechat-subscriber.swig' %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>前面添加代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      &#123;% if not is_index %&#125;</span><br><span class="line">        &#123;% include 'my-copyright.swig' %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>修改<code>themes/next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import <span class="string">"my-post-copyright"</span></span><br></pre></td></tr></table></figure></p><p>最后到<code>站点根目录/scaffolds/post.md</code>，在两个<code>---</code>中间增加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyright: true</span><br></pre></td></tr></table></figure></p><p>之后的每一篇文章都会自己加上版权信息，之前的文章也可以通过在文章对应的md文件头部加上以上代码添加版权信息。</p><hr><h3 id="添加分享文章功能"><a href="#添加分享文章功能" class="headerlink" title="添加分享文章功能"></a>添加分享文章功能</h3><p>这里我们使用<a href="https://www.addthis.com/" target="_blank" rel="noopener">AddThis</a>，为什么呢，晒一下我的样式你就知道了：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519547206460.jpg" alt="enter description here"><br>具体选择什么样式可以在AddThis网站上面设置。<br>首先注册账号（需要科学上网），注册后找到该位置：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519547553087.jpg" alt="enter description here"><br>在<strong>主题配置文件</strong>中搜索<code>add_this_id</code>，去掉前面的注释，添加上你的<code>AddThis ID</code>就可以了。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Share  分享</span></span><br><span class="line"><span class="comment">#jiathis: true</span></span><br><span class="line"><span class="comment"># Warning: JiaThis does not support https. 博主实测支持https</span></span><br><span class="line"><span class="attr">add_this_id:</span> <span class="string">&#123;your</span> <span class="string">AddThis</span> <span class="string">ID&#125;</span></span><br></pre></td></tr></table></figure><p>具体添加方式如下，可以选择多种样式：<br><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519547877122.jpg" alt="enter description here"></p><hr><h3 id="添加文章评分功能"><a href="#添加文章评分功能" class="headerlink" title="添加文章评分功能"></a>添加文章评分功能</h3><p>通过<a href="https://widgetpack.com/" target="_blank" rel="noopener">widgetpack</a>来给网站每篇文章添加评分系统，效果如下：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519549080064.jpg" alt="enter description here"><br>首先注册账号，添加新站点，填入网站名称和域名地址，点击添加：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519549179322.jpg" alt="enter description here"><br>获取id：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519549234020.jpg" alt="enter description here"><br>这里9384就是我的id，复制下来到<strong>主题配置文件</strong>中搜索<code>widgetpack</code>添加即可:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  id:</span>  <span class="string">&#123;your</span> <span class="string">ID&#125;</span>    <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line"><span class="attr">  color:</span>  <span class="string">fc6423</span></span><br></pre></td></tr></table></figure></p><p>这里建议设置为按ip地址记录评分，比较方便：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519549428255.jpg" alt="enter description here"></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519549442267.jpg" alt="enter description here"></p><hr><h3 id="文章排序优先级设置"><a href="#文章排序优先级设置" class="headerlink" title="文章排序优先级设置"></a>文章排序优先级设置</h3><p>修改<code>hero-generator-index</code>插件，把文件<code>node_modules/hexo-generator-index/lib/generator.js</code>内的代码替换为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在<code>\scaffolds\post.md</code>头部<code>---</code>中添加以下代码：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top:</span></span><br></pre></td></tr></table></figure></p><p>以后新建文章就可以给文章的<code>top</code>赋值，数值越大优先级越高。</p><blockquote><p>已经写好的文章在对应的md文件头部添加<code>top：{number}</code>即可</p></blockquote><hr><h3 id="添加站内搜索功能"><a href="#添加站内搜索功能" class="headerlink" title="添加站内搜索功能"></a>添加站内搜索功能</h3><p>这里使用<a href="https://www.algolia.com/" target="_blank" rel="noopener">Algolia</a>，其他的都不太靠谱。<br>前往Algolia注册页面，注册一个新账户。可以使用GitHub或者Google账户直接登录，注册后的14天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户总共有10,000条记录，每月有100,000的可以操作数。注册完成后，创建一个新的Index，这个Index将在后面使用。</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519550030640.jpg" alt="enter description here"><br>Index创建完成后，此时这个Index里未包含任何数据。接下来需要安装<code>Hexo Algolia</code>扩展，这个扩展的功能是搜集站点的内容并通过API发送给Algolia。前往站点根目录，执行命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-algolia</span><br></pre></td></tr></table></figure></p><p>找到新建的Index对应的Key，复制下面的<code>App ID</code>和<code>API Key</code>，同时修改权限:</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519550149671.jpg" alt="enter description here"></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519550364302.jpg" alt="enter description here"></p><p>在<strong>站点配置文件</strong>（注意是站点配置文件）末尾，新增配置代码：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加搜索</span></span><br><span class="line"><span class="attr">algolia:</span></span><br><span class="line"><span class="attr">  applicationID:</span> <span class="string">'&#123;your appID&#125;'</span></span><br><span class="line"><span class="attr">  apiKey:</span> <span class="string">'your API Key'</span></span><br><span class="line"><span class="attr">  indexName:</span> <span class="string">'your Index name'</span></span><br><span class="line"><span class="attr">  chunkSize:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure></p><p>在站点根目录执行以下代码，更新Index(每次更新文章都需要执行一次)，即上传站点内容到algolia：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> HEXO_ALGOLIA_INDEXING_KEY=&#123;your API Key&#125;</span><br><span class="line">$ hexo algolia</span><br></pre></td></tr></table></figure></p><p>更改<strong>主题配置文件</strong>，搜索<code>algolia_search</code>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  hits:</span></span><br><span class="line"><span class="attr">    per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line"><span class="attr">    hits_empty:</span> <span class="string">"We didn't find any results for the search: $&#123;query&#125;"</span></span><br><span class="line"><span class="attr">    hits_stats:</span> <span class="string">"$&#123;hits&#125; results found in $&#123;time&#125; ms"</span></span><br></pre></td></tr></table></figure></p><p>将<code>enable</code>改为<code>true</code>即可，根据需要你可以调整<code>labels</code>中的文本。 </p><hr><h3 id="DaoVoice-在线联系"><a href="#DaoVoice-在线联系" class="headerlink" title="DaoVoice 在线联系"></a>DaoVoice 在线联系</h3><p>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519571899528.jpg" alt="enter description here"></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519571880134.jpg" alt="enter description here"><br>首先去<a href="http://dashboard.daovoice.io/" target="_blank" rel="noopener">注册</a>，这里需要<a href="http://dashboard.daovoice.io/get-started?invite_code=5ea4435c" target="_blank" rel="noopener">邀请码</a>，贴一个<code>5ea4435c</code>，或者直接点击邀请码的链接。注册后就可以查看你的<code>app_id</code>:</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519572185895.jpg" alt="enter description here"><br>复制<code>app_id</code>，打开<code>/themes/next/layout/_partials/head.swig</code>,写下如下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span>(<span class="params">i,s,o,g,r,a,m</span>)</span>&#123;i[<span class="string">"DaoVoiceObject"</span>]=r;i[r]=i[r]||<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;(i[r].q=i[r].q||[]).push(<span class="built_in">arguments</span>)&#125;,i[r].l=<span class="number">1</span>*<span class="keyword">new</span> <span class="built_in">Date</span>();a=s.createElement(o),m=s.getElementsByTagName(o)[<span class="number">0</span>];a.async=<span class="number">1</span>;a.src=g;a.charset=<span class="string">"utf-8"</span>;m.parentNode.insertBefore(a,m)&#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">"script"</span>,(<span class="string">'https:'</span> == <span class="built_in">document</span>.location.protocol ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">"//widget.daovoice.io/widget/0f81ff2f.js"</span>,<span class="string">"daovoice"</span>)</span></span><br><span class="line"><span class="javascript">  daovoice(<span class="string">'init'</span>, &#123;</span></span><br><span class="line"><span class="javascript">      app_id: <span class="string">"&#123;&#123;theme.daovoice_app_id&#125;&#125;"</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="javascript">  daovoice(<span class="string">'update'</span>);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>接着打开<strong>主题配置文件</strong>，在最后写下如下代码：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Online contact</span></span><br><span class="line"><span class="attr">daovoice:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">daovoice_app_id:</span> <span class="string">&#123;your</span> <span class="string">app_id&#125;</span></span><br></pre></td></tr></table></figure></p><p>具体样式设计可以在 应用设置–&gt;聊天设置 后边改。</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519572587089.jpg" alt="enter description here"></p><hr><h2 id="个性化优化"><a href="#个性化优化" class="headerlink" title="个性化优化"></a>个性化优化</h2><h3 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h3><p>在<strong>主题配置文件</strong>中设置，例如：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 外链字体库地址，例如 //fonts.googleapis.com (默认值)</span></span><br><span class="line"><span class="attr">  host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 全局字体，应用在 body 元素上</span></span><br><span class="line"><span class="attr">  global:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Monda</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 标题字体 (h1, h2, h3, h4, h5, h6)</span></span><br><span class="line"><span class="attr">  headings:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Roboto</span> <span class="string">Slab</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 文章字体</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Logo 字体</span></span><br><span class="line"><span class="attr">  logo:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Lobster</span> <span class="string">Two</span></span><br><span class="line"><span class="attr">    size:</span> <span class="number">24</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 代码字体，应用于 code 以及代码块</span></span><br><span class="line"><span class="attr">  codes:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">PT</span> <span class="string">Mono</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="设置代码高亮主题"><a href="#设置代码高亮主题" class="headerlink" title="设置代码高亮主题"></a>设置代码高亮主题</h3><p>NexT 默认使用的是  normal 主题，可选的值有 normal，night， night blue， night bright， night eighties：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519393453073.jpg" alt="enter description here"></p><hr><h3 id="设置小型代码块颜色"><a href="#设置小型代码块颜色" class="headerlink" title="设置小型代码块颜色"></a>设置小型代码块颜色</h3><p>修改<code>\themes\next\source\css\_variables\base.styl</code>文件，修改$code-background和$code-foreground的值：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">Code</span> <span class="string">&amp;</span> <span class="string">Code</span> <span class="string">Blocks</span></span><br><span class="line"><span class="string">//</span> <span class="bullet">--------------------------------------------------</span></span><br><span class="line"><span class="string">$code-font-family</span>               <span class="string">=</span> <span class="string">$font-family-monospace</span></span><br><span class="line"><span class="string">$code-font-size</span>                 <span class="string">=</span> <span class="number">13</span><span class="string">px</span></span><br><span class="line"><span class="string">$code-font-size</span>                 <span class="string">=</span> <span class="string">unit(hexo-config('font.codes.size'),</span> <span class="string">px)</span> <span class="string">if</span> <span class="string">hexo-config('font.codes.size')</span> <span class="string">is</span> <span class="string">a</span> <span class="string">'unit'</span></span><br><span class="line"><span class="string">$code-border-radius</span>             <span class="string">=</span> <span class="number">3</span><span class="string">px</span></span><br><span class="line"><span class="string">$code-foreground</span>                <span class="string">=</span> <span class="string">$black-light</span></span><br><span class="line"><span class="string">$code-background</span>                <span class="string">=</span> <span class="string">$gainsboro</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="左上角或右上角的Github样式"><a href="#左上角或右上角的Github样式" class="headerlink" title="左上角或右上角的Github样式"></a>左上角或右上角的Github样式</h3><p>实现效果有两种：<br><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519389578682.jpg" alt="enter description here"><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519389609199.jpg" alt="enter description here"><br>具体实现方式便是到<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">样式1</a>或者<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">样式2</a>的网站中选择你喜欢的样式，复制其中的代码到<code>themes/next/layout/_layout.swig</code>文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面)，并把<code>href</code>改为你的github地址。</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519390078850.jpg" alt="enter description here"></p><hr><h3 id="添加背景动画"><a href="#添加背景动画" class="headerlink" title="添加背景动画"></a>添加背景动画</h3><p>NexT已经自带了多种背景动画效果，你只需要根据需求在<strong>主题配置文件</strong>修改其中一个为<code>true</code>即可。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest </span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Only fit scheme Pisces</span></span><br><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>实现效果：<br><img src="http://upload-images.jianshu.io/upload_images/5308475-ef603580be708882.gif?imageMogr2/auto-orient/strip" alt="引用自http://shenzekun.cn"></p><hr><h3 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h3><p>在<strong>主题配置文件</strong>中搜索<code>pace</code>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading. 加载条</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-minimal</span></span><br></pre></td></tr></table></figure></p><p>这里有多种主题选择，根据自己喜好选择主题修改便可。</p><hr><h3 id="点击出现小爱心效果"><a href="#点击出现小爱心效果" class="headerlink" title="点击出现小爱心效果"></a>点击出现小爱心效果</h3><p>效果：<br><img src="http://upload-images.jianshu.io/upload_images/5308475-78e64c0a80bb559e.gif?imageMogr2/auto-orient/strip" alt="引用自http://shenzekun.cn"><br>将<a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="noopener">love.js</a>文件放到路径<code>/themes/next/source/js/src</code>里面，然后打开<code>\themes\next\layout\_layout.swig</code>文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h3><p>修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="修改文章底部标签样式"><a href="#修改文章底部标签样式" class="headerlink" title="修改文章底部标签样式"></a>修改文章底部标签样式</h3><p>修改<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519399277326.jpg" alt="enter description here"><br>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519399326851.jpg" alt="enter description here"></p><hr><h3 id="文章末尾统一添加“本文结束”标记"><a href="#文章末尾统一添加“本文结束”标记" class="headerlink" title="文章末尾统一添加“本文结束”标记"></a>文章末尾统一添加“本文结束”标记</h3><p>在路径<code>\themes\next\layout\_macro</code>中新建<code>passage-end-tag.swig</code>文件,并添加以下内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #555;font-size:14px;"</span>&gt;</span>-------------The End-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在这个位置添加代码：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519399742916.jpg" alt="enter description here"><br>要添加的代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include 'passage-end-tag.swig' %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后打开<strong>主题配置文件</strong>，在末尾添加：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519399937181.jpg" alt="enter description here"></p><hr><h3 id="修改作者头像并旋转"><a href="#修改作者头像并旋转" class="headerlink" title="修改作者头像并旋转"></a>修改作者头像并旋转</h3><p>打开<code>\themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>，在里面添加如下代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">$site</span>-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="variable">$site</span>-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$site</span>-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$site</span>-author-image-border-width solid <span class="variable">$site</span>-author-image-border-color;</span><br><span class="line">  <span class="comment">/* 头像圆形 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="number">#333</span>sf;</span><br><span class="line">  <span class="comment">/* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </span></span><br><span class="line"><span class="comment">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  -webkit-<span class="attribute">transition</span>: -webkit-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  -moz-<span class="attribute">transition</span>: -moz-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>:hover &#123;</span><br><span class="line">  <span class="comment">/* 鼠标经过停止头像旋转 </span></span><br><span class="line"><span class="comment">  -webkit-animation-play-state:paused;</span></span><br><span class="line"><span class="comment">  animation-play-state:paused;*/</span></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  -webkit-<span class="attribute">transform</span>: rotateZ(<span class="number">360deg</span>);</span><br><span class="line">  -moz-<span class="attribute">transform</span>: rotateZ(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: rotateZ(<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Z 轴旋转动画 */</span></span><br><span class="line">@-webkit-keyframes play &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: rotateZ(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: rotateZ(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-moz-keyframes play &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    -moz-<span class="attribute">transform</span>: rotateZ(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    -moz-<span class="attribute">transform</span>: rotateZ(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes play &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: rotateZ(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: rotateZ(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="文章添加阴影效果"><a href="#文章添加阴影效果" class="headerlink" title="文章添加阴影效果"></a>文章添加阴影效果</h3><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line"> <span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519400499904.jpg" alt="enter description here"></p><hr><h3 id="修改打赏部分字体动画"><a href="#修改打赏部分字体动画" class="headerlink" title="修改打赏部分字体动画"></a>修改打赏部分字体动画</h3><p>Next打赏部分的动画是鬼畜一般的不停地抖动，看着很难受，所以博主把它改为只循环三遍，打开文件<code>themes/next/source/css/_common/components/post/post-reward.styl</code>，把微信和支付宝的改为如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wechat</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>: roll <span class="number">0.1s</span> <span class="number">3</span> linear;</span><br><span class="line">    <span class="attribute">-webkit-animation</span>: roll <span class="number">0.1s</span> <span class="number">3</span> linear;</span><br><span class="line">    <span class="attribute">-moz-animation</span>: roll <span class="number">0.1s</span> <span class="number">3</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#alipay</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>: roll <span class="number">0.1s</span> <span class="number">3</span> linear;</span><br><span class="line">    <span class="attribute">-webkit-animation</span>: roll <span class="number">0.1s</span> <span class="number">3</span> linear;</span><br><span class="line">    <span class="attribute">-moz-animation</span>: roll <span class="number">0.1s</span> <span class="number">3</span> linear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="自定义鼠标样式"><a href="#自定义鼠标样式" class="headerlink" title="自定义鼠标样式"></a>自定义鼠标样式</h3><p>打开<code>themes/next/source/css/_custom/custom.styl</code>，添加代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 鼠标样式</span><br><span class="line">  * &#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">"http://om8u46rmb.bkt.clouddn.com/sword2.ico"</span>),auto<span class="meta">!important</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">"http://om8u46rmb.bkt.clouddn.com/sword1.ico"</span>),auto<span class="meta">!important</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>其中 url 里面必须是 ico 图片，ico 图片可以上传到网上（推荐七牛云图床），然后获取外链，复制到 url 里就行了。</p><hr><h3 id="添加看板娘"><a href="#添加看板娘" class="headerlink" title="添加看板娘"></a>添加看板娘</h3><p>实现效果：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519570879462.jpg" alt="enter description here"><br>用git bash在站点根目录执行如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure></p><p>然后打开<code>/themes/next/layout/_layout.swig</code>,将下面代码放到<code>&lt;/body&gt;</code>之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; live2d() &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>在<strong>站点配置文件</strong>末尾添加代码：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 看板娘</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  model:</span> <span class="string">hijiki</span></span><br><span class="line"><span class="attr">  position:</span> <span class="string">left</span></span><br><span class="line"><span class="attr">  bottom:</span> <span class="bullet">-30</span></span><br><span class="line"><span class="attr">  mobileShow:</span> <span class="literal">false</span>  <span class="comment">#手机端不显示</span></span><br></pre></td></tr></table></figure></p><p>具体设置可以看官方介绍–<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">传送门</a>。</p><hr><h2 id="学习借鉴的文章"><a href="#学习借鉴的文章" class="headerlink" title="学习借鉴的文章"></a>学习借鉴的文章</h2><ol><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</a></li><li><a href="http://blog.csdn.net/MasterAnt_D/article/details/56839222" target="_blank" rel="noopener">http://blog.csdn.net/MasterAnt_D/article/details/56839222</a></li><li><a href="http://blog.csdn.net/lemonxq/article/details/72676005" target="_blank" rel="noopener">http://blog.csdn.net/lemonxq/article/details/72676005</a></li></ol>]]></content>
    
    <summary type="html">
    
      持续更新的基于NexT主题的优化教程。目前网上很多的教程都已经是很旧的了，而且不少已经失效或者有更好的实现方式，本文主要汇总网上众多的优化方案并筛选其中可用的部分同时依据NexT最新版本做出修改以保证本文的教程始终有效。
    
    </summary>
    
      <category term="建站" scheme="http://alvabill.ml/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="hexo" scheme="http://alvabill.ml/tags/hexo/"/>
    
      <category term="NexT" scheme="http://alvabill.ml/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客--基础篇</title>
    <link href="http://alvabill.ml/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2--%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://alvabill.ml/hexo搭建个人博客--基础篇/</id>
    <published>2018-01-30T11:46:00.000Z</published>
    <updated>2018-09-07T05:51:52.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>基于hexo搭建个人blog的文章在网上已经有很多了，不过由于时间的原因有很多已经不再适用或者说留下了很多坑，本文是基于个人这些天搭建的经历，踩了无数坑把这些坑给填上后总结出的目前最简易也是最靠谱的方法，相信小白看着也能直接搭建一个漂亮美观可随时访问的个人博客，嘿嘿，先晒一晒自己的成果，个人还是比较满意的–<a href="http://alvabill.ml/">我的blog</a>。</p><h2 id="hexo介绍"><a href="#hexo介绍" class="headerlink" title="hexo介绍"></a>hexo介绍</h2><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517474896002.jpg" alt=""><br>官网上的描述是<a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo</a>是一个快速，简单而强大的博客框架。您可以使用Markdown（或其他语言）编写文章，Hexo可以在几秒钟内生成具有美丽主题的静态文件。</p><p>简单来说它就是一个主打简单快速的博客框架，这个可以对比下知名度更高一些的WordPress，相对来说后者更强，不过更适合有服务器的人使用，比如你去购买个阿里云什么的建站那种，不过我们这次追求简洁，不想在服务器折腾，后文会介绍具体在哪里架设我们的博客，而且hexo可以魔改…给爱折腾的人用也很不错，另外hexo基于现在大热的nodeJS，可以配合学习一下，这也是我选择它的出发点之一。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>声明一下，本教程主要针对windows用户，其他平台用户在某些操作上可能有些不一致，可以在评论区或者右下角留言交流。</p><p>如有需要本教程会持续更新。</p><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>下载并安装<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>（安装就是一直next就可以）</p><p>git主要用于版本控制，另外这里hexo的操作很多都需要在git bash进行，不然会出现奇怪错误，想要了解更多git知识可以参考以下链接：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程–廖雪峰网站</a>。当然，直接跟着本教程走也是完全没问题的。</p><h3 id="NodeJS安装"><a href="#NodeJS安装" class="headerlink" title="NodeJS安装"></a>NodeJS安装</h3><p>关于NodeJS的一些介绍可以稍微看一下这篇文章–<a href="https://www.cnblogs.com/fang-beny/p/4778591.html" target="_blank" rel="noopener">NodeJS简介</a>，在本教程中NodeJS主要用于管理下载第三方包，例如hexo，而这些工作都是npm在负责的。<br>1.下载并安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS</a><br>这里选择最新的稳定版本v8.9.4安装过程可以一路next，不过推荐在选择安装路径时选择D盘，然后记住路径名，一般情况下是<code>D:\Program Files\nodejs\</code><br>安装后输入<code>Win+R</code>输入<code>cmd</code>打开控制台输入以下代码：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果返回版本号即安装完成，否则就需要配置环境变量（参考步骤2中的图片）再测试</p><p>2.NodeJS配置<br>配置npm<br>我们要先配置npm的全局模块的存放路径以及cache的路径，最好在nodejs安装路径下建立”node_global”及”node_cache”两个文件夹。如下图：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517476774171.jpg" alt=""><br>启动cmd，输入</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix "D:\Program Files\nodejs\node_global"</span><br><span class="line">npm config <span class="built_in">set</span> cache "D:\Program Files\nodejs\node_cache"</span><br></pre></td></tr></table></figure><p>配置环境变量（win10可以通过小娜查询“环境变量”找到入口），如下图打开</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517477579071.jpg" alt=""><br>框中的三条记录是必须的（路径改为你们自己的路径）</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517477681510.jpg" alt=""><br>测试是否配置完成，可以安装express来进行测试，打开cmd，输入</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure><p>完成后在<code>node_global</code>目录下查看是否存在express目录即可。</p><h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><p>打开git bash，为了避免出现错误后面的操作在git bash进行<br>首先新建一个存放hexo文件的目录，例如在D盘根目录新建<code>hexo</code>文件夹，然后cd到该目录下，开始安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> D:hexo/ <span class="comment">#换成你的目录</span></span><br><span class="line">$ npm install -g hexo-cli  <span class="comment">#安装hexo脚手架</span></span><br><span class="line">$ hexo init  <span class="comment">#Hexo自动在当前文件夹下下载搭建网站所需的所有文件</span></span><br><span class="line">$ npm install  <span class="comment">#安装依赖包</span></span><br><span class="line"></span><br><span class="line">$ hexo g <span class="comment">#完整命令为hexo generate，生成静态文件</span></span><br><span class="line">$ hexo s <span class="comment">#完整命令为hexo server，启动服务器，用来本地预览</span></span><br></pre></td></tr></table></figure><p>用浏览器访问<code>http://localhost:4000/</code>，这时就可以看到了一个比较漂亮的博客了，这个是hexo的默认主题landscape，而我们会使用的是NexT主题，这个在后面会说到如何配置。</p><h3 id="Github-Coding"><a href="#Github-Coding" class="headerlink" title="Github/Coding"></a>Github/Coding</h3><p>本地博客搭建好了接下来是要把它部署到网上，这里可以选择<a href="https://github.com/" target="_blank" rel="noopener">github</a>和国内的<a href="https://coding.net/" target="_blank" rel="noopener">coding</a>平台，后者在打开自己网站时会跳出广告，前者访问速度比较慢，大家自行选择，然后我现在的话是两个同时在使用。<br>注册部分我就不说了，如果两个都注册的话建议名字取相同的。下面详细说一下github和coding的Pages服务如何创建<br>1.Github Page<br>打开github主页，新建仓库（repository），这里要注意仓库的名称，比如我的帐号是<code>alvabill</code>，那么仓库名称应该是：<code>alvabill.github.io</code>。</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517480208966.jpg" alt=""></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517480336865.jpg" alt="这里警告是因为我已经创建过该仓库"></p><p>2.Coding Page<br>Coding的操作和github相差无几</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517480543241.jpg" alt=""></p><p>新建一个名为<code>{user_name}.coding.me</code> 的项目。<code>{user_name}</code> 指您本人的用户名，例如我的用户名为<code>alvabill</code></p><p><img src="https://dn-coding-net-production-pp.qbox.me/799fcc2d-88ec-43fb-b122-044d8b33eafb.png" alt="自己的报错，用一下别家的图了"></p><h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><p>以上过程完成后就是把hexo生成的静态页面上传了，以为要结束了吗，还没呢，这里还需要配置SSH，首先要本地生成公钥私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"你的邮件地址"</span></span><br></pre></td></tr></table></figure><p>引号里面的内容输入你的邮箱地址，然后回车，会提示你文件保存的路径，这时候按回车键确认，然后会提示你输入密码，输入即可（输入密码是看不到的），然后会确认输入一次，就可以在刚刚的路径看到生成了两个文件，一个是<code>id_rsa</code>，另一个是<code>id_rsa.pub</code>，用<a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime</a>打开<code>id_rsa.pub</code>然后选中里面的全部内容，复制下来。<br>打开GitHub或Coding的SSH页面<br>Github：setting–&gt;SSH and GPG keys–&gt;New SSH key</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517481884400.jpg" alt=""><br>Coding：</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517481952168.jpg" alt=""></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>打开<code>D:\hexo</code>，用sublime打开<code>_config.yml</code>文件，文件最后可以看到</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span></span><br></pre></td></tr></table></figure><p>修改（注意要换上自己的链接）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span>   <span class="comment">#发布到github</span></span><br><span class="line">  <span class="comment">#repository: git@git.coding.net:yourname/yourname.git            #发布到Coding</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>或者同时发布到两个平台：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span></span><br><span class="line"><span class="attr">    github:</span> <span class="string">git@github.com:yourname/yourname.github.io.git,master</span></span><br><span class="line"><span class="attr">    coding:</span> <span class="string">git@git.coding.net:yourname/yourname.git,master</span></span><br></pre></td></tr></table></figure></p><p><code>ctrl+s</code>保存修改。<br>打开git bash在当前目录输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d <span class="comment">#完整命令为hexo deploy，将本地文件发布到page服务平台上</span></span><br></pre></td></tr></table></figure><p>如遇遇到异常可以<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><p>如果出现以下异常</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>Deployer not found: git</span><br></pre></td></tr></table></figure><p>尝试输入以下命令，然后重新执行刚刚的两条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这时候如果弹出一个对话框，输入在github/coding上面的用户名和密码即可<br>这时候我们就可以在浏览器输入<a href="https://yourname.github.io" target="_blank" rel="noopener">https://yourname.github.io</a> 或者<a href="https://youname.coding.me" target="_blank" rel="noopener">https://youname.coding.me</a> 打开</p><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><p><code>D:\hexo</code>目录下的<code>theme</code>文件夹下存放的就是博客的主题，hexo便是依据主题来生成静态文件的，挑选主题可以在官网<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 查找，根据自己的喜好来挑选。<br>下载主题的方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site  <span class="comment">#eg:D:\hexo</span></span><br><span class="line">$ git <span class="built_in">clone</span> &#123;主题链接&#125; themes/&#123;主题名称&#125;</span><br></pre></td></tr></table></figure><p>启用主题的方式也很简单<br>sublime打开上文提到的<code>hexo</code>目录下的<code>_config.yml</code>，<code>ctrl+f</code>输入<code>theme</code>查找这个关键字，修改其主题名称为下载的主题名称即可。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">&#123;主题名称&#125;</span></span><br></pre></td></tr></table></figure><p>以本人使用的next主题为例：<br>下载最新版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> D:hexo/</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>修改<code>hexo</code>目录下的<code>_config.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>具体可以到主题官网看看–<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a></p><h3 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h3><p>经过以上过程我们已经实现了一个可以即时访问的个人博客，不过我们想要的是一个更酷的更个性化的域名，下面就看一下如何申请一个免费的域名然后配置到我们的github/Coding Page上面，实现以个人域名访问自己的博客。<br>1.免费域名<br>这里推荐一个网站<a href="https://my.freenom.com" target="_blank" rel="noopener">Freenom</a>，点进去注册，注册之后按照以下步骤进入下面这个页面，然后就可以在输入框处输入你喜欢的名字查找域名了</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517508131471.jpg" alt=""><br>既然是个人博客，那当然还是找自己昵称啦，例如我的昵称，查找有免费的域名后就点击加入购物车~</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517508261452.jpg" alt=""></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517508321452.jpg" alt=""></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517508368555.jpg" alt=""><br>最后别忘了拖到最后点击确认购买</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517508442720.jpg" alt=""><br>这里可以选择免费一年，域名快到期前的一个星期会发邮件提醒续期，续期也是不要钱的，也就是可以一直免费使用了。点击continue确认然后填写一堆信息后就能获取到了。</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517508616330.jpg" alt=""></p><p>回到初始界面后查看自己的域名，可以看到刚刚购买的域名已经在列表下了</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517508874508.jpg" alt=""></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517508962220.jpg" alt=""><br>2.使用第三方DNS解析工具<br>虽然freenom自身也能进行DNS解析，但是毕竟不适合国内的朋友使用。所以我们使用国内的DNSPOD、CloudXNS等第三方DNS工具。<br>这里介绍如何使用<a href="https://www.cloudxns.net/" target="_blank" rel="noopener">CloudXNS</a>管理，一如既往的先注册，这里好像需要身份证验证了，挺麻烦的，不过为了我们的域名能好好的用上，还是只能选择原谅他啊。<br>进入控制台–&gt;我的域名，点击添加域名，例如刚刚弄到手的<code>alvabill.ga</code></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517509290333.jpg" alt=""></p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517509340935.jpg" alt=""><br>然后会跳出这么一个提示</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517509419598.jpg" alt=""><br>意思就是要到freenom那边把域名接管过来，好的，我们先记住那一段蓝色字</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv3ns1<span class="selector-class">.ffdns</span><span class="selector-class">.net</span></span><br><span class="line">lv3ns2<span class="selector-class">.ffdns</span><span class="selector-class">.net</span></span><br><span class="line">lv3ns3<span class="selector-class">.ffdns</span><span class="selector-class">.net</span></span><br><span class="line">lv3ns4<span class="selector-class">.ffdns</span><span class="selector-class">.net</span></span><br></pre></td></tr></table></figure><p>打开freenom刚刚的那个界面，点击对应域名的manage Demain按钮进入域名管理界面</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517509507009.jpg" alt=""><br>进入NS服务器管理界面</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517509649013.jpg" alt=""><br>选择Use custom nameservers (enter below)，然后把刚刚记录的那四段字符串复制粘贴进去，点击change nameservers</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517509876570.jpg" alt="enter description here"></p><p>完成，回到CloudXNS，等半分钟刷新一下就有了，可以现在就点击开启，或者之后配置好了点击开启。</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517510074853.jpg" alt=""></p><h3 id="域名绑定Page服务"><a href="#域名绑定Page服务" class="headerlink" title="域名绑定Page服务"></a>域名绑定Page服务</h3><p>1.添加记录<br>如下为我的域名的记录，记录值分别为coding page和github page的网址，你们只需要修改这两个值，其他和我的一样配置便可。如果是只使用一个page服务就只需要两条对应的记录，然后记得要把线路类型都设置为全网默认哦。</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517510582432.jpg" alt=""></p><p>2.配置Page服务<br><a href="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517510817702.jpg" target="_blank" rel="noopener">GitHub</a>：<br>进入<code>{yourname}.github.io</code>仓库–&gt;Settings，向下找到以下界面，在红框处填入你的域名</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517510817702.jpg" alt=""><br>到<code>D:\hexo\sourse</code>目录下（即你安装hexo的目录下的sourse目录下）新建文件<code>CNAME</code>，用Sublime打开填入你的域名，如<code>alvabill.ml</code>，保存。<br>然后到<code>D:\hexo</code>目录下用sublime打开<code>_config.yml</code>，<code>ctrl+f</code>查找<code>skip_render</code>，然后改为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">README.md</span>  </span><br><span class="line"><span class="bullet">  -</span> <span class="string">CNAME</span></span><br></pre></td></tr></table></figure><p>这个指令就是可以跳过<code>CNAME</code>和<code>README.md</code>文件，防止每次hexo重新渲染把它们清除掉。这里的<code>README.md</code>可有可无，最好还是有，因为每个github项目都需要一个<code>readme</code>文件，添加位置和<code>CNAME</code>一样。</p><p><a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>：<br>进入项目–&gt;pages服务，填入域名，绑定~</p><p><img src="http://p3dm71oa7.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517511580763.jpg" alt=""></p><p>最后重新布置项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d -g</span><br><span class="line">$ hexo g &amp;&amp; hexo s   <span class="comment">#如需本地预览，执行这一条</span></span><br></pre></td></tr></table></figure><p>浏览器输入你的域名回车，就可以成功访问你的个人博客了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>摸索了一段时间才完成的，还是很有成就感的，比较遗憾的是并没有很好地记录下自己搭建这么一个网站的过程，教程写完后总感觉漏了什么，当时遇到的问题应该还是挺多的，再加上重新写博客时无法再次亲身经历那种由无到有的过程，难免会有不少疏漏的地方，欢迎大家在评论区或私戳我进行讨论，遇到什么问题也欢迎提出，我会及时地进行修正的。<br>下一篇文章将介绍如何优化以及个性化Next.mist主题。如果你也喜欢这个主题的话，可以继续关注我的更新~~</p>]]></content>
    
    <summary type="html">
    
      本文为基于hexo搭建个人博客同时用上自己的域名来进行访问的一个全面性的教程，区别于网上其他较为分散的教程，本教程使用的都是最新可用的方法，避免了那些历史遗留的bug，同时通过博主的亲身经历来为大家绕过可能会踩到的坑，算是较为完整全面地实现一个小白友好的项目。
    
    </summary>
    
      <category term="建站" scheme="http://alvabill.ml/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="hexo" scheme="http://alvabill.ml/tags/hexo/"/>
    
  </entry>
  
</feed>
